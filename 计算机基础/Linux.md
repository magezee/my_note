## Linux

### 目录规范

**Linux一般相应的文件都会会放在相应的目录下。这样更有利于文件的查找**

- **home**：用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
- **/root**：系统管理员的主目录
- **/bin**：二进制可执行命令
- **/dev**：设备特殊文件
- **/etc**：系统管理和配置文件
- **/etc/rc.d**：启动的配置文件和脚本
- **/lib**：标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
- **/sbin**：超级管理命令，这里存放的是系统管理员使用的管理程序
- **/tmp**：公共的临时文件存储点
- **/mnt**：系统提供这个目录是让用户临时挂载其他的文件系统
- **/lost+found**：这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
- **/proc**：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
- **/var**：某些大文件的溢出区，比方说各种服务的日志文件
- **/usr** ：最庞大的目录，要用到的应用程序和文件几乎都在这个目录

---

### 用户和组的概念

Linux是多用户多任务的系统   ———— 很多用户同时用同一个系统，但并不所有的用户都一定都要做同一件事（即可以同时有多个用户连进该主机并同时工作）

    用户的角色区分：
    在Linux 系统中，由于角色不同，权限和所完成的任务也不同（用户的角色是通过UID识别的 在系统管理中系统管理员一定要坚守UID唯一的特性）
    root 用户：系统唯一，是真实的，可以登录系统，可以操作系统任何文件和命令，拥有最高权限
    
    虚拟用户：这类用户也被称之为伪用户或假用户，与真实用户区分开来，这类用户不具有登录系统的能力，但却是系统运行不可缺少的用户
    如（bin、daemon、adm、ftp、mail等） 这类用户都系统自身拥有的，而非后来添加的，当然我们也可以添加虚拟用户
    
    普通真实用户：这类用户能登录系统，但只能操作自己家目录的内容；权限有限；这类用户都是系统管理员自行添加的
```
用户的概念
ect目录下的passwd文件保存系统中所有的用户和用户的主要信息   可用 vi（或cat） /etc/passwd 打开查看    每一个:隔开一个字段 一共有七个字段
（如果只是想看自己创建的用户 则在/home里查看文件夹名字就行）
       
root:X:0:0:root:/root:/bin/bash
root --用户名称（用户名称只是为了方便管理员记忆 Linux 系统是通过用户 ID (UID) 来区分不同用户 分配用户权限的）
           
X --该用户是拥有密码的
           
0 --用户ID/UID
	0               代表这个账号是管理员账号
    1~499           系统用户（伪用户） 1~499 范围内的用户是不能登录系统的，而是用来运行系统或服务的
    1~99        	系统保留的账号 系统自动创建
    100~499     	预留给用户创建账号
    500~65535       普通用户
                           
0 --用户组ID/GID      该用户的初始组的标志号（注意只显示初始组）
    初始组 ———— 指用户一登陆录就立刻拥有这个用户组的相关权限 每个用户的初始组只能有一个，一般就是将和这个用户的用户名相同的组名作为这个用户的初始组
    	如手工添加用户 lamp，在建立用户 lamp 的同时就会建立 lamp 组作为 lamp 用户的初始组
    附加组 ———— 指用户可以加入多个其他的用户组，并拥有这些组的权限（用户除了初始组之外的组）
    	初始组和附加组的身份是可以修改的 但是在工作中不修改初始组 只修改附加组 因为修改了初始组有时会让管理员逻辑混乱）
                                    
root --这个用户的简单说明 没有什么特殊作用 可以不写   
           
/root --用户的家目录 也就是用户登录后有操作权限的访问目录 
	Linux的根目录是目录的最高层，所有文件都在根目录下面，而根目录下有bin，etc，root，mnt等文件目录，而家目录在/home/用户名里面
    	root用户的家目录不在home里面，而在/root）  
                            
/bin/bash --登录之后的Shell（Linux的命令解释器）———— 可理解为用户登录之后所拥有的权限
 	如  
    /bin/bash 		代表这个用户拥有权限范围内的所有权限
    sbin/nologin    代表禁止该用户登录
    Linux 的标准 Shell 就是 /bin/bash，Shell 的作用就是把 ASCII 编码的命令翻译成系统可以识别的机器语言，同时把系统的执行结果翻译为用户可以识别的 ASCII 编码
                                
```

```
用户组的概念：
   用户组（group）就是具有相同特征的用户（user）的集合体
   要让多个用户具有相同的权限 比如查看、修改某一文件或执行某个命令 这时我们需要用户组
       1.把指定用户都定义到同一用户组
       2.修改文件或目录的权限 让用户组具有一定的操作权限
       (这样用户组下的用户对该文件或目录都具有相同的权限，这是我们通过定义组和修改文件的权限来实现的)
           举例：
               我们为了让一些用户有权限查看某一文档，比如是一个时间表，而编写时间表的人要具有读写执行的权限，我们想让一些用户知道这个时间表的内容，而不让他们修改
               所以我们可以把这些用户都划到一个组，然后来修改这个文件的权限，让用户组可读，这样用户组下面的每个用户都是可读的
    
```

---

### 文件权限

```
[root@local opt]#ls -al
        -rw-r--r--  1 root root    81 08-02 14:54 gtkrc-1.2-gnome2
        -rw-------  1 root root   189 08-02 14:54 ICEauthority
        -rw-------  1 root root    35 08-05 10:02 .lesshst
        drwx------  3 root root  4096 08-02 14:54 .metacity
        drwxr-xr-x  3 root root  4096 08-02 14:54 nautilus
```

**列表的列定义:**
            [权限属性信息] [连接数] [拥有者] [拥有者所属用户组] [大小] [最后修改时间] [文件名]

    权限属性列表为10个字符:
        第一个字符表示文件类型
            d为目录 -为普通文件 l为连接 b为可存储的接口设备 c为键盘鼠标等输入设备
            
        第二个字符表示所有者读权限 
            如果有权限则为r，没有权限则为-
    
        第三个字符表示所有者写权限
            如果有权限则为w，没有权限则为-
    
        第四个字符表示所有者执行权限
            如果有权限则为x，没有权限则为-
    
        第五个字符表示所有者同组用户读权限
            如果有权限则为r，没有权限则为-
    
        第六个字符表示所有者同组用户写权限
            如果有权限则为w，没有权限则为-
    
        第七个字符表示所有者同组用户执行权限
            如果有权限则为x，没有权限则为-
    
        第八个字符表示其他非同组读权限
            如果有权限则为r，没有权限则为-
    
        第九个字符表示其他非同组写权限
            如果有权限则为w，没有权限则为-
                
        第十个字符表示其他非同组执行权限
            如果有权限则为x，没有权限则为-
---



### 重定向

**Linux的标准输入与输出**

| 设备   | 设备名      | 文件描述符 | 类型         |
| :----- | :---------- | :--------- | :----------- |
| 键盘   | /dev/stdin  | 0          | 标准输入     |
| 显示器 | /dev/stdout | 1          | 标准输出     |
| 显示器 | /dev/stderr | 2          | 标准错误输出 |

```
文件描述符
Linux 系统为文件分配的一个数字，范围0-3 

一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件:
标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。
标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。
标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。
```

**输入重定向**

是指不使用系统提供的标准输入端口，而进行重新的指定

```markdown
如：
cat命令的默认输入是键盘，默认输出是显示屏，即cat的功能是将键盘输入的内容显示到显示屏上
cat > a.txt
将键盘输入的内容写进a.txt文件内，显示屏不会显示信息
cat < a.txt（功能和cat a.txt一样）
从键盘输入更改为文件，等于从a.txt中读取内容然后显示到显示屏
cat < a.txt > b.txt
从a.txt中读取文件，然后输出到b.txt,实际上相当于将a覆盖b
cat << delimiter(标识符字符串任意，一般指定delimiter)
读取键盘内容，直到输入delimiter字符串，输出输入内容到显示屏（不包括标识符）
```

| 类型           | 语法                         | 功能                                             |
| -------------- | ---------------------------- | ------------------------------------------------ |
| 标准输入       | 命令   <   文件              | 将文件的内容作为标准输入设备                     |
| 标识符限定输入 | 命令   <<   标识符           | 从标准输入中读入内容，直到遇到“标识符”分解符为之 |
| 输入输出重定向 | 命令   <   文件1   >   文件2 | 将文件1的内容作为标准输入，输出到文件2           |

**输出重定向**

一般而言，重定向输出就是把要输出的文件信息写入到一个文件中去，而不是将要输出的文件信息输出到控制台（显示屏）

```
/dev/null
如果希望执行某个命令，但是不希望在屏幕上显示输出结果，可以将输出重定向到/dev/null
该文件时是一个特殊文件，任何写入它的内容都会被丢弃，也无法读取到任何内容
```

| 类型           | 语法             | 功能                                                   |
| -------------- | ---------------- | ------------------------------------------------------ |
| 标准输出重定向 | 命令   >   文件  | 将命令执行正确的输出内容输出到指定文件，覆盖原来文件   |
| 标准输出重定向 | 命令   >>   文件 | 将命令执行正确的输出内容输出到指定文件，追加到原来文件 |
| 类型               | 语法              | 功能                                                   |
| ------------------ | ----------------- | ------------------------------------------------------ |
| 标准错误输出重定向 | 命令   2>   文件  | 将命令执行错误的输出内容输出到指定文件，覆盖原来文件   |
| 标准错误输出重定向 | 命令   2>>   文件 | 将命令执行错误的输出内容输出到指定文件，追加到原来文件 |

| 类型                            | 语法                           | 功能                                                         |
| ------------------------------- | ------------------------------ | ------------------------------------------------------------ |
| 正确/错误同时输出重定向         | 命令   >   文件   >   2>&1     | 将命令执行正确或错误的输出内容输出到指定文件，覆盖原来文件   |
| 正确/错误同时输出重定向         | 命令   >>   文件   >   2>&1    | 将命令执行正确或错误的输出内容输出到指定文件，追加到原来文件 |
| 正确/错误同时输出重定向（简写） | 命令   &>   文件               | 将命令执行正确或错误的输出内容输出到指定文件，覆盖原来文件   |
| 正确/错误同时输出重定向（简写） | 命令   &>>   文件              | 将命令执行正确或错误的输出内容输出到指定文件，追加到原来文件 |
| 正确/错误同时输出重定向         | 命令   >>   文件a   2>   文件b | 将命令执行正确的输出以追加方式写到文件a，执行错误的结果以覆盖的方式写到文件b |

---



### 管道

**命令执行顺序控制**

通常情况下，在终端只能执行一条命令，然后按下回车执行

- 顺序执行多条命令：command1;command2;command3;
  简单的顺序指令可以通过 `;`来实现

- 有条件的执行多条命令：which command1 && command2 || command3
  `&&` : 如果前一条命令执行成功则执行下一条命令，如果command1执行成功（*返回0*）,则执行command2

  `||` :与&&命令相反，执行不成功时执行这个命令

**管道命令**

管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）

管道命令使用`|`作为界定符号，管道命令与上面说的连续执行命令不一样

- 管道命令仅能处理`标准输出`,对于`标准错误输出`会予以忽略

  less,more,head,tail...都是可以接受standard input的命令，所以他们是管道命令

  ls,cp,mv并不会接受standard input的命令，所以他们不是管道命令

- 管道命令必须要能够接受来自前一个命令的数据成为`标准输出`继续处理才行

```
如：
ls | cat > a.txt
执行ls，将其结果作为cat的输入，然后将cat的结果输出到a.txt
```

**tee管道命令**

读取标准输入的数据，并将其内容输出成文件

```
tee [选项] [文件名]
选项：
-a：追加到文件而非覆盖
-i：忽略中断信号
```

```
如：
data > a.txt			// 将结果写入到a.txt文件中，控制台不会显示输出
data | tee -a a.txt		// 将结果写入到a.txt文件中，同时控制台显示输出
```



---

### 技巧性

#### 开机启动程序

`/etc/rc.d/rc.local` 用于用户自定义开机启动程序，可以往里写开机要执行的命令或脚本

```
如vim打开并写入cd /home 则表示开机时自动进入home目录	
```









----

### 指令

#### 操作用户、组相关

**切换指定用户（从root用户进入其他用户时无需输入密码）**

```
su +用户名
su - +用户名			// 登入后自动切换到/home/xx 用户目录 一般都加-登入

su - 登入方式登入时执行
/etc/profile
/etc/bashrc
~/.bash_profile		  // ~./ 表示 home/用户文件夹
~/.bashrc

su 登入方式时执行
/etc/bashrc
~/.bashrc

用户切出时会执行
~/.bash_logout
~/.bash_history
```

---

**创建组**

```shell
groupadd -g + GID +组名
# 如 group -g 4399 magezee
```

----

**创建用户**

```shell
\# useradd -m + 用户名 -g + 主组 -G + 附组
# 如：useradd -u 4399 -g 4399 -m magezee    UID不能重复
# 创建用户前应先创建组
# 如果不用-m，则不会自动生成/home下的用户目录
```

----

**设置密码**

```
passwd +用户名
```

---

**删除用户**

```
 usedel -r +用户名      // -r 将该用户/home/用户 下的文件也删除
```

---

**赋权给指定用户对文件(目录)的权限**

```
 chown -R +用户:组 +绝对路径   
 // 如 chown -R yzadmin:yzgrp /usr/local/redis
```

---

**设置用户密码永不过期**

```
change -M 99999 +指定用户名
```

---



#### 查询相关

**查看系统信息**

```
uname -a			// 内核、操作系统、CPU信息
top					// 主机内存和cpu使用情况
df -hl				// 服务器硬盘使用情况
du -h -d n  		// 当前目录及n级子目录的硬盘使用大小 (du -h -d 1 表示查看当前文件夹和一级子目录的使用情况)
```

---

**查看用户、组信息**

```
cat /etc/passwd			// 查看当前主机所有用户信息
cat /etc/group			// 查看当前主机所有组信息
groups					// 查看当前用户所属组
groups +用户名			  // 查看指定用户所属组
id +用户名				  // 查看服务器是否存在该用户名，若存在返回该用户信息
```

---

**查看当前用户终端历史输入指令**

```
history
```

----

**查找文件位置**

````
find .			// 列出当前目录及子目录下所有文件和文件夹
find +路径	  // 通过关键字查找
````

如果想全服务器查找则路径指定为 / 即可

```
find / -name mongodb	// 全局查找mongodb文件路径
```

name 表示依赖匹配字符查找，如果是iname表示忽略大小写

```
find /home -iname "*.txt"						// 在/home目录下查找以.txt结尾的文件名，忽略大小写
find . \( -name "*.txt" -o -name "*.pdf" \)		// 当前目录及子目录下查找所有以.txt和.pdf结尾的文件
```

regex表现依赖正则表达式查找，如果是iregex表示忽略大小写

```
find . -regex ".*\(\.txt\|\.pdf\)$"				// 基于正则表达式匹配文件路径
```

! 表示否定

```
find /home ! -name "*.txt"		// 找出/home下不是以.txt结尾的文件
```

type 表示根据文件类型进行搜索

```
find . -type f		// 查找当前目录及子目录下所有文件
find . -type d		// 查找当前目录及子目录下所有目录
```



----

#### 操作文件、目录相关

**查看当前路径下的所有子目录/文件**

```
ls			// 简单信息
ll			// 详细信息（包括文件权限）
la			// 简单信息，包括被隐藏的 隐藏目录、文件的名字第一个字符为'.'
ls -la		// 包括隐藏文件、目录的详细信息
```

---

**路径**

```
cd +路径	  // 进入指定路径
cd			// 不加路径时，会直接进入到用户的home
cd .. 		// 返回上一级目录
pwd			// 查看当前路径
```

---

**判断文件、目录**

```
[ -d +路径 ]			# 判断目录是否存在(true为0)		
[ -e +路径 ]		    # 判断是否存在
[ -f +路径 }			# 判断是否为文件

等同于
test -d +路径	
……
```

---

**查看指定文件内信息**

```
tail +文件名
```

---

**执行指定文件**

```
./ +文件名			// 执行当前目录下的文件
绝对路径 +文件名	 // 执行文件
```

---

**移动文件（重命名）**

```
mv +文件名1 +文件名2	 			// 当前目录下重命名
mv +路径/文件名 +新路径/文件名		// 将指定文件移动到指定路径（也可新命名重命名）
```

---

**新建、删除文件和文件夹**

```
touch +文件名（含后缀）		// 新建文件
mkdir +文件夹名			  // 新建文件夹
rm +文件名			 	   // 删除文件
rm -rf +文件夹名		  // 删除文件夹
```

---

**全局查找文件存在路径（如果是路径则会查出包含该路径的全部路径）**

```
find / （文件名/路径）
```

**在终端打开指定文件（可对文件内容进行编辑 vim也命令差不多）**

```
 vi +文件名		// 当vi打开一个不存在的文件时，默认创建该文件，因此也可用vi来创建文件
 	在vi打开的文件有三种模式
 		命令模式
 			i 		--切换到输入模式，以输入字符
 			x 		--删除当前光标所在字符
 			: 		--切换到底线命令模式，以在最低一行输入命令
 		输入模式
 			Esc 	--切换到命令模式
 		底线命令模式
 			Esc 	--切换到命令模式
 			w 		--保存
 			w! 		--当文件属性为只读时，强制保存，要求对文件有权限
 			q 		--离开vi
 			q!		--若对文件进行过修改，不想储存时，强制离开
 			wq		--保存并退出
 			wq!		--强制保存退出
 			ZZ		--若文件有过修改，则保存退出，若无改动，则退出
```

---

**查看文件内容（不可编辑）**

```
cat +文件名		
```

---

**更改文件所有者**

```
chown +用户:组 +文件名
```

---

**修改文件执行权限**

最高权限777和775

读取权限 r=4

写入权限 w=2

执行权限 x=1

777的每个7分别代表拥有者，组用户，其他用户权限

777表示该文件所有用户有读取、写入、执行权限，而775不同的是其他用户有读取和执行权限而没有写入权限（4+1）

```
chmod [选项] +文件名
选项：
r --可读
w --可写
x --可执行

修改文件夹及子文件夹权限可以用  chmod -R 777 +文件夹路径 或 chown -R 777 +文件夹路径
```

---

**压缩和解压**

Linux中可以识别的常见压缩格式如.zip、.gz、.bz2、.tar、.tar.gz、.tar.bz2等
Linux不支持.rar和.tz格式的压缩文件

- .zip格式

  zip是Windows中最常见的压缩格式，Linux也可以正确识别

```
压缩
zip [选项] 压缩包名 源文件或源目录
选项：
-r：压缩目录
如：
zip ana.zip anaconda-ks.cfg

解压
unzip [选项] 压缩包名
选项：
-d：指定解压缩位置
如：unzip -d /tmp/ test.zip
```

- .gz格式

  gz格式和bz2格式是Linux中最常见的压缩格式

```
压缩和解压
gzip [选项] 源文件
选项：
-c：将压缩数据输出到标准输出中，可用于保留源文件
-d：解压
-r：压缩目录
```

注意：使用gzip压缩文件后会将原文件删除，如果想保留原文件则可以使用-c选项将压缩过程产生的标准输出写入一个新的文件中，示例如下：>的作用是覆盖内容，>>的作用是追加内容

```
gzip -c anconda-ks.cfg > anconda-ks.cfg.gz	// 压缩文件的同事不删除源文件
```

压缩目录下的每个文件：下述命令会将123这个目录下的每个文件分别进行压缩，而不是将整个123目录进行压缩，也就是说**gzip命令不会打包压缩**

```
gzip -r 123
```

- .bz2格式

bz2格式是Linux中的另一种常用压缩格式，该格式的压缩算法更先进，压缩比更高，但是压缩的时间要比.gz长，.bz2格式的压缩命令是bzip2，**注意bzip2不能压缩目录，会报错**

```
压缩和解压
bzip2 [选项] 源文件
选项：
-d：解压缩
-k：压缩时，保留源文件
-v：显示压缩的详细信息
```

- .tar格式：只是打包并不会压缩文件，tar格式的打包和解打包都是使用tar命令，区别只是选项不同

  由于gzip和bzip2不能打包只能压缩，而tar只能打包不会压缩，因此可以先使用tar打包，然后使用gzip或bzip2进行压缩

```
打包
tar [选项] [-f 压缩包名] 源文件或目录
选项：
-c：打包
-f：指定压缩包的文件名
-v：显示打包文件过程
如：tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg	// 打包，压缩

解包：
tar [选项] [压缩包]
选项：
-x：解包
-f：指定压缩包文件名
-v：显示打包过程
-t：测试，只是查看包中有哪些文件，不解包
-C：指定解包目录
如：
tar -xvf test.tar -C /tmp/test		// 解包到/tmp/test目录下
```

- .tar.gz格式和.tar.bz2格式（tar.gz格式会简写为tgz，其他同理）

  使用tar命令后跟选项的方式实现tar命令和gzip或者bzip2命令的组合，实现同时进行打包和压缩，这也是最经常使用的压缩和解压缩方式

```
tar [选项] 压缩包 源文件或目录
选项：
-z：压缩和解压 .tar.gz 格式
-j：压缩和解压 .tar.bz2 格式
如：
tar -zcvf tmp.tar.gz /tmp/		// 把/tmp/目录直接打包压缩为tar.gz格式
tar -zxvf tmp.tar.gz			// 解压和解包tar.gz
tar -jcvf tmp.tar.bz2 /tmp/		// 打包压缩为tar.bz2格式
tar -jxvf tmp.tar.gz /tmp/		// 解压和解包tar.bz2
```

---



#### 其他

**清屏**

```
clear
```

---

**执行历史操作**

```
!：
! +number		// 执行历史记录序号为number的操作
! +string		// 执行按string模糊匹配的历史记录中最后一个操作
!!				// 执行上一步历史操作				
```

---

**打印（相当于printf）**

```
echo
```

**判断命令是否成功执行**

```
$?		// 存储上一条命令的执行成败 成功为0    
可搭配 echo $? 来进行判断
```

**过滤结果**

```
grep +正则表达式
free -m | grep '^Mem'
```

**传输文件**

使用SecureCRT软件登入服务器的情况下：

```
文件 → 连接SFTP标签页
put +文件名	// 将指定文件放在SFTP标签页的当前目录下（要求文件在传输默认路径中 一般默认路径为我的文档）
get +文件名	// 将服务器中的指定文件下载到本地的默认路径
```



---



## Shell

### shell文件的执行方式

- **路径直接执行**

```
/marisue/Desktop/test.sh		// 绝对路径
./test.sh						// 相对路径（在/marisue/Desktop使用）
```

路径执行的方式不会指定编译方式，由#！确定编译（写在顶部）

```
#!/usr/bin/bash			
#!/usr/bin/python			// 只有最顶部的#!有效，其他均会被识别为 #注释
```

路径执行的文件需要文件执行权限

```
chmod x +文件名		// 加可执行权限
chmod 777 +文件名		// 加最高权限
```

- **指定编译执行**

即使写了#!也不会生效，会由指定的编译器来编译

```
bash test.sh
python test.py
bash test.py		// 报错
```

- **在当前终端中执行**

与上面两种不同，. 执行方式会在当前终端中执行并返回结果，而上面两种相当于另开了一个终端，获取到结果后再将其返回到当前终端

```shell
test.sh:
#!/usr/bin/bash
cd /home
ls
```

```
. test.sh		// 注意.后带一个空格
```

如上面shell程序，若使用./test.sh执行，则会进入到/home返回ls结果，但是当前终端的路径不会cd到/home

而用. test.sh执行时，会将当前终端的路径转到/home并返回ls结果

---



### shell中使用其他语言

**在shell中调用python**

```shell
#!/usr/bin/bash
ping -cl 192.168.18.1 && echo 'success' || echo 'fail'

/user/bin/python <<-EOF
	print "hello world"
EOF
echo 'finish'
```

于一开始执行了一段shell脚本，然后使用输出重定向，相当于在shell文件里写了另外的一个文件，内容print "hello world"，将其文件输出给python来执行，执行完后再返回到shell文件里继续执行shell

---

### 编程常用

#### 变量

- **直接声明并赋值，用\$或\${}引用**

```bash
ip=192.168.18.1  
ping $ip		# 或者ping${ip}
```

- **声明，执行程序时再从键盘获取值**

``` shell
read -p "Please input a ip:\n" ip	# 可选参数：-p +字符串 
ping $ip
```

- **系统定义变量（使用时要带$，如\${1}）**

```shell
0				 # 返回执行的sh文件的路径 
1、2、3……		   # 位置变量，不能直接赋值，会在执行程序命令时跟的参数确定 跟的第一个参数为1 第二个为2 以此类推（bash test.sh 192.168.18.1）
*			     # 返回sh文件中引用的所有参数的值
@			     # 返回sh文件中引用的所有参数的值
#				 # 返回sh文件中引用的所有参数的个数
$				 # 返回执行sh文件时使用的进程id
?				 # 返回上一条命令的结果，执行正确返回0
()				 # 执行程序时先执行括号里的命令，将其结果保存起来等待新的一个命令使用
```

```shell
#!/usr/bin/bash
if [ $# -eq 0 ];then  # 相当于 if($# == 0)
	echo "usage：`basename $0` file"  
	exit  # 退出当前执行该文件的shell，exit执行后文件下方的内容全都不会执行
fi

if [ ! -f $1 ]; then
	echo "error file!"
	exit
fi

for ip in `cat $1`		
do
	ping -c1 $ip &>/dev/null
	if [ &? -eq 0 ]; then
		echo "${ip} is up. "
	else
		echo "${ip} is down!"
	fi
done

# ``和$()的作用差不多（但并不是所有类unix系统都支持$()）
# 相当于 parma = basename $0 (执行这段命令并将结果保存在parma 但是不能在脚本里直接赋值 可以parma = `basename $0`)
## echo "usage：${parma} file"  
```

- **可以在终端中直接定义局部变量和环境变量**

  局部变量作用范围：仅当前shell

  环境变量作用范围：当前shell和子shell

```shell
ip1=192.168.18.1			# 定义局部变量	
export ip2=192.168.18.2		# 定义环境变量
export ip1					# 将局部变量定义成环境变量
unset						# 删除变量
```

```shell
test.sh:
ping ${ip1}

./test.sh		# 在终端（shell）执行命令时，默认会在子shell中执行完然后再将结果返回到当前shell，所以如果在没有定义变量的sh文件中去使用变量，如果该变量不是环境变量时，则无法引用
```

- **变量赋值（当变量赋值带空格时，需要用""包起来（a="hello world"））**

```shell
显示赋值
parma = value
a = 1
a = `cat test.txt`
a = $(cat test.txt)
# 注意：``和$()里不能出现变量${}，他是强引用
# 如a=1;num=`number is ${a}`;echo ${num}   结果："number is ${a}"   变量不会生效

# read从键盘读取变量值（可以同时设置多个变量，空格分隔，若设置的变量<程序引用变量，则程序里的变量为null ）
read parma
read -p “提示信息” parma
read -t time -p "提示信息" parma 		# 等待time(s)
read -n strLen parma				   # 从键盘读取的最多字符个数为strLen
```

- **变量运算**

```shell
expr  声明之后的命令为运算(同时，乘运算符*需要转义为\*)
sum = `expr $num1 + $num2`

$(())  括号里不需要$引用变量，可直接使用  
sum = $((num1 + num2))

$[]  等同$(())
sum = $[num1 + num2]

let
sum = let num1 + num2
let i++
```

- **变量内容的删除和替换**

删除：

```shell
url = www.sina.com.cn
返回长度
${#url}				# 15
从后往前，删除到指定字符
${url#www.}			# sina.com.cn
最短匹配，只删到第一个满足条件的字符
${url#*.}			# sina.com.cn
贪婪匹配，删到最后一个满足条件的字符
${url##*.}			# cn
从后往前删（其他使用一样）
${url%%*.}			# www
（注意，他的匹配模式和正则表达式不一样，如果是#删，则指定的字符串必须字符串开头，%同理）
${url#a.}			# www.sina.com.cn 因为开头为www..因此不会找到a.
${url#*a.}			# con.cn 这里的*为一个以上任意个字符，相当于${url#www.sina.}
```

截取：

```shell
url = www.sina.com.cn			
${url:5:5}			# ina.c
${url:5}			# ina.com.cn
```

替换：

```shell
url = www.sina.com.cn
${url/sina/baidu}		# www.baidu.con.cn
${url/n/N}				# www.siNa.com.cn
${url//n/N}				# www.siNa.com.cN
```

变量替代：

```shell
# 变量不定值（只声明不赋值）
unset var1
echo ${var1-value_1}		# value_1
echo{$var1}					# 空
# 变量定非空值得情况下
var2 = 2
echo ${var2-value_2}		# 1
# 变量定空值情况下
var3 = 
echo ${var3-value_3}		# 空


${param-newValue}		# 若param不定值，返回newValue
${param:-newValue}    	# 若param不定值或空值，返回newValue

${param+newValue}		# 若param空值或非空值，返回newValue
${param:+newValue}		# 若param非空值，返回newValue

${param=newValue}		# 若param不定值，返回newValue且令param=newValue
${param:=newValue}		# 若para不定值或空值，返回newValue且令param=newValue

${param?newValue}		# 若param不定值，将newValue标准错误输出
${param:?newValue}		# 若param不定值或为空，将newValue标准错误输出
```



#### 条件测试

test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试

三种写法：

- test 条件表达式

- [ 条件表达式 ]
- [[ 条件表达式 ]]

```shell
# 整数 [ int_1 -eq int_2 ]
-eq		# ==
-ne		# !=
-gt		# >
-ge		# >=
-lt		# <
-le		# <=

# 文件 [ -d file ]
-d		# 判断目录是否存在		
-e		# 判断是否存在
-f		# 判断是否为文件
-r		# 判断文件是否具有可读权限
-w		# 判断文件是否具有可写权限
-x		# 判断文件是否具有可执行权限
-s		# 判断文件是否为非空白文件

# 字符 [ str_1 = str2 ]
=		# 判断两个字符串是否相等
!=		# 判断两个字符串是否不相等
-z		# 判断字符串是否为空
-n		# 判断字符串是否不为空

# 逻辑 [ int_1 -eq int_2 -a -d file ]
-a 		# 并
-o		# 或
!		# 取反
```

```shell
# 数值
#!/bin/bash
read num1 num2
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
```

```shell
#字符
#!/bin/bash
if [ $USER = "root" ];then		# USER是系统变量，存储当前登入用户名字
	echo "你没有权限！"
	exit
fi
apt install httpd 
```

```shell
# 文件
#!/bin/bash
back_dir=/var/mysql_back
# 没有该文件夹则创建
if ! test -d ${back_dir};then	# 这里的！是表示取反的意思
	mkdir -p $back_dir
fi
echo "开始备份"
```



---



### 指令

```shell
()		# 子shell中执行
(())	# 数值比较，运算C语言
$()		# 命令替换
$(())	# 整数运算

{}		# 集合
${}		# 变量

[]		# 条件测试
[[]]	# 条件测试，支持正则 =~
$[]		# 整数运算
```

---

### 程序范例

```shell
#!/bin/bash
read -p "Please input a username: " user
if id $user &>/dev/null;then
	ehco "user $user already exists"
else
	useradd $user
	if [ $? -eq 0 ];then
		echo "$user is created"
	fi
fi
```

