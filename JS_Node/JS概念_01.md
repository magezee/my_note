## JS概念

### 进程和线程

- 进程是资源分配最小单位，线程是程序执行的最小单位

- 进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据

- CPU切换一个线程比切换进程花费小

- 创建一个线程比进程开销小

- 线程占用的资源要⽐进程少很多

- 线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行（但多线程程序处理好同步与互斥是个难点）

- 多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）

- 进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换


```
http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html
```



----

### 执行上下文

- 当函数运行的时候，会生成一个叫做 “执行上下文” 的东西，也可以叫做执行环境，它用于保存函数运行时需要的一些信息

- 执行上下文内部存储了包括：**变量对象**、**作用域链**、**this 指向** 这些函数运行时的必须数据

- 一个函数能够访问到的上层作用域，在函数创建的时候就已经被确定且保存在函数的 `[[scope]]` 属性里，和函数拿到哪里去执行没有关系
- 所有的执行上下文都会被交给系统的`执行上下文栈`来管理，它是一个栈结构数据，全局上下文永远在该栈的最底部，每当一个函数执行生成了新的上下文，该上下文对象就会被压入栈，但是上下文栈有容量限制，如果超出容量就会栈溢出

-----

**执行上下文类型：**

javascript 中有三种类型

- **全局执行上下文**

​       这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，它在整个`javascript` 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 `window`），并且将 `this` 值绑定到这个全局对象上

- **函数执行上下文**

  每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的）

- **Eval 函数执行上下文**

​       执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，eval是一个用于转义字符传为可执行代码语句的函数，js里用的不多

-----

**执行上下文内容：**

可以将它理解为一个 `object` ，包括以下内容

- 变量对象

- 活动对象

- 作用域链

- 调用者信息

----

**执行上下文生命周期**

**创建阶段**

发生在函数调用时且在执行函数体内的具体代码之前

- 用当前函数的参数列表（`arguments`）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 变量和函数将作为属性添加到这个变量对象上。在这一阶段，会进行（变量/函数提升）变量和函数的初始化声明，变量统一定义为 `undefined` 需要等到赋值时才会有确值，而函数则会直接定义

- 构建作用域链
- 确定 `this` 指向

**执行阶段**

执行阶段中，JS 代码开始逐条执行，在这个阶段，JS 引擎开始对定义的变量赋值、开始顺着作用域链访问变量、如果内部有函数调用就创建一个新的执行上下文压入上下文执行栈，并定位到下一层执行栈开始执行

**销毁阶段**

函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，往上层搜索执行上下文栈并定位执行

-----

#### 调用栈

当一段脚本运行起来的时候，可能会调用很多函数并产生很多函数执行上下文，为了解决管理执行上下文的问题，`javascript` 引擎创建了 “执行上下文栈” （`Execution context stack` 简称 `ECS`）来管理执行上下文

执行上下文栈是栈结构的，因此遵循 `LIFO`（后进先出）的特性，代码执行期间创建的所有执行上下文，都会交给执行上下文栈进行管理

- 当 JS 引擎开始解析脚本代码时，会首先创建一个**全局执行上下文**，压入栈底（这个全局执行上下文从创建一直到程序销毁，都会存在于栈的底部）
- 每当引擎发现一处函数调用，就会创建一个新的**函数执行上下文**压入栈内，并将控制权交给该上下文，待函数执行完成后，即将该执行上下文从栈内弹出销毁，将控制权重新给到栈内上一个执行上下文

当函数间没有互相调用的关系时，执行完一个函数会立即进行销毁（弹出栈）并加入新执行的函数

```jsx
function A() {	}

function B() {  }

A()
B()
```

<img src="https://img-blog.csdnimg.cn/20200516181834164.png" style="margin:0px"> 

当函数间存在引用关系时，由于A函数需要调用B函数，因此A函数真正执行完后是在执行完B函数后，因此需要保留A函数的栈，同时压入B函数，等待B函数执行完后弹出B函数，然后等待A执行完再弹出A

```jsx
function A() {	
	B()
}

function B() {  }

A()
```

<img src="https://img-blog.csdnimg.cn/20200516181610672.png" style="margin:0px">



**因此如果函数间互相调用的次数过多，过多的栈没有被销毁，可能会出现栈溢出（如高次数的递归）**

----

#### global和window

顶层对象在浏览器环境中指的是window对象，在Node环境中指的是global对象，浏览器环境无global顶级对象，node环境无window顶级对象

```
变量只有全局变量和局部变量两种
下面涉及到顶层对象的变量实际上是在顶层对象里添加了一个全局变量属性
```

**global**

在node环境中，使用关键字声明的对象是全局变量，而顶层对象global是比全局变量还要更高一级的，因此在作用链下寻找时，先找到全局变量 ，找不到会往上层的顶级对象中找

```jsx
// vscode下调试
var a = 1
global.b = 2			// 使用global声明顶级对象变量，和不用关键字直接声明(b = 2)作用一样

console.log(global.a)	// undefined，顶级对象中找不到，父级无法拥有子级内容
console.log(b)			// 2，全局对象中找不到，会往父级对象中找
```

**window**

在浏览器环境中，全局变量会自动存储在顶级对象window属性中，即声明顶层对象变量和声明全局变量都是一样的

```jsx
// Chrome下调试
var a = 1

console.log(window.a)	// 1
console.log(a)			// 1
```

**变量泄漏**

如果不使用声明语句，则相当于声明了一个顶级对象属性，不用的话实际上声明了一个全局变量（无论node环境还是浏览器环境都是），造成变量泄漏（危险）

```javascript
function fun() {
	a = 1;

}
fun()
console.log(a)	// 1
```

**不同环境下的this指向**

全局调用一个函数时，node环境下this指向global，浏览器环境下this指向window

```jsx
var a = 1

function foo () {  
	console.log(this.a)
}

foo()	
// 全局调用时，this指向顶级对象
// vscode调试打印 undefined，因为没有找不到global.a
// chrome调试打印 1，var a 等同于windw.a 因此能寻找到
```

```jsx
a = 1

function foo () {  
	console.log(this.a)
}

foo()
// vscode调试打印 1
// chrome调试打印 1
```



----

#### 变量提升和函数提升

JS代码中，会自动将声明提到它坐在的作用于的顶端去执行，然后到在代码原所在的位置进行赋值,函数提升优先于变量提升

**变量提升**

```javascript
console.log(a);  // 输出结果为undefined
var a = 123;
```

实际执行顺序为：

```javascript
var a;
console.log(a);
a = 123;
```

因此在执行console.log(a)的时候a的值还没有被赋予123，于是输出undefined

```javascript
console.log(v1);
var v1 = 100;
function foo() {
    console.log(v1);
    var v1 = 200;
    console.log(v1);
}
foo();
console.log(v1);

// 输出结果
// undefined
// undefined
// 200
// 100
```

**函数提升**

函数声明也会被提升（仅函数声明式会存在函数提示）

```javascript
//函数声明式
function bar() {}
//函数字面量式，这种和声明变量后赋值没什么区别
var foo = function() {}
```

```javascript
console.log(fun1)
console.log(fun2)
var fun2 = function() {
    console.log('fun2的方法')
}

function fun1() {
    console.log('fun1的方法')
}
```

实际执行顺序为：

```javascript
function fun1() {
    console.log('fun1的方法')
}
var fun2
console.log(fun1)
console.log(fun2)
fun2 = function() {
    console.log('fun2的方法')
}

/*
最终输出结果：
    [Function: fun1]
    undefined
*/
```

---

#### 块级作用域

一共有三种作用域：

- 全局作用域
- 块级作用域
- 函数作用域

块级作用域一般以`{}`为范围，一般指 `存粹括号域`、`if语句`和几种 `循环语句`（注意函数的括号属于函数作用域）

**let和const**

let和const不存在变量和提升和变量泄漏，const和let对比只是表示常量不可更改（而且const声明时要赋值），其余功能一样

```javascript
console.log(a)			// undefind
console.log(b)			// 错误
console.log(c)          // 错误
{
    var a = 10
    let b = 10
    const c = 10
}
console.log(a)			// 10
console.log(b)			// 错误
console.log(c)          // 错误
```

注意上面的只是一个括号来表示一块块级作用域，如果是函数的话就不行

```js
function demo(){
    var a = 10
    let b = 10
    const c = 10
}
console.log(a)			// 错误
console.log(b)			// 错误
console.log(c)          // 错误
```

这种情况常出现于循环和判断语句这些块级作用域中

```js
console.log(a)			// undefined
console.log(b)			// 错误
console.log(c)          // 错误
for(var i; i<2; i++) {
    var a = 10
    let b = 10
    const c = 10
}
console.log(a)			// undefined
console.log(b)			// 错误
console.log(c)          // 错误
```

```js
console.log(a)			// undefined
console.log(b)			// 错误
console.log(c)          // 错误
if(true) {
    var a = 10
    let b = 10
    const c = 10
}
console.log(a)			// 10
console.log(b)			// 错误
console.log(c)          // 错误
```

不存在变量提升：

```javascript
console.log(a)		// undefind
console.log(b)		// 错误
var a = 10
let b = 10
```

var声明的变量提升是提至块级作用域外的

```js
console.log(a)          // undefined，没有报错，说明这里已经声明了变量a
{
	var a = 10
	console.log(a)		// 10
}
```

不可重复声明

```javascript
let b = 10	
let b = 11			// 错误
```

若块级作用域中声明了同名块级变量，则屏蔽外围同名变量，这是因为优先在自身作用域内寻找变量，没有找到才向上寻找，如果在内部声明了同名变量则优先在自身找

```javascript
let a = 'a'
let b = 'b'
{
    console.log(a)		// a
	console.log(b)		// 错误
	let b = 'bb'
	console.log(b)		// bb
}
```

由于var提升至外部，无法屏蔽同名变量，因为这里相当于两次`var a`的声明都是在外部声明而在自身作用域中没有声明过同名变量

```js
var a = 'a'
var b = 'b'
{
    console.log(a)		// a
	console.log(b)		// b
	var b = 'bb'		// 这里如果使用let声明则可以起到屏蔽作用
	console.log(b)		// bb
}
```

const声明对象时，不可更改对象引用，但可更改对象属性

```javascript
const teacher{
    name:'Jack',
    age:25
}

teacher.name = 'Lucy'		// OK

teacher = {
    name:'Lucy',
    age:25
}							// 报错
```

**循环**

在for循环参数中声明循环变量，默认var在全局里，而let在函数内部声明

```jsx
for(var i = 0; i< 5; i++){

}
console.log(i)		// 5

// 等同于

var i = 0
for(; i< 5; i++){

}
console.log(i)		// 5
```

```js
var  i = 0

for(var i = 1; i<0 ;){
	
}
console.log(i)	// 1
```

```js
for(var i =2; i<0 ;) {

}
console.log(i)  // 2
```

```jsx
for(let i = 0; i< 5; i++){

}
console.log(i)		// 报错，因为let声明在函数内部，因此外部的i是未定义的
```

如果声明在外部，就和var是一样的

```jsx
let i = 0

for(; i< 5; i++){

}
console.log(i)		// 5
```

因此for循环内部如果存在异步函数时，使用let而非var，因为会造成意外结果

```jsx
for(var i =0; i< 5; i++){
	setTimeout(() => {
		console.log(i)		// 5 5 5 5 5
    })
    console.log(i)          // 0 1 2 3 4
}

for(let i =0; i< 5; i++){
	setTimeout(() => {
		console.log(i)		// 0 1 2 3 4
	})
}
```

for循环相当于下面这些代码，let和var全部执行在异步函数前，由不同特性可知，var之间会相互影响，而let不会

```js
{
    var i = 0
    setTimeout(() => {console.log(i)})		// 2
}
{
    var i = 1	
    setTimeout(() => {console.log(i)})		// 2
}
{
    var i = 2
    setTimeout(() => {console.log(i)})		// 2
}
```

```js
{
    let i = 0
    setTimeout(() => {console.log(i)})		// 0
}
{
    let i = 1
    setTimeout(() => {console.log(i)})		// 1
}
{
    let i = 2
    setTimeout(() => {console.log(i)})		// 2
}
```

如果一定要用var来处理，那可以使用递归的方式

```js
function demo(i) {
    if(i <5) {
        setTimeout(() => {
            console.log(i)
            i += 1
            demo(i)
        })
    }
}

demo(0)     // 0 1 2 3 4
```



----

#### 函数作用域

函数作用域和块级作用域不同：变量提升只会提升到函数内顶部，不会提升至外部

```js
console.log(a)          // 报错
console.log(b)   		// undefined 
// 函数作用域     
function test() {       
    console.log(a)      // undefined
    var a = 'a'
}
test()
// 块级作用域
{
    var b = 'b'
}
```



----

#### 闭包

只要满足一个函数在另一个函数的内部的条件，这个内部函数就是闭包，不管这个内部函数是以怎样的形式存在于外层函数中的，闭包能访问它所在外层函数全部变量

```
闭包的主要用途：可以让外界（闭包函数的外界）读取到函数内部的变量

闭包的问题：主要是内存泄漏，在函数的生命周期结束时，手动释放掉这个引用，设置成 `null` 

因为如果一个函数内部有闭包存在，那么函数之行结束后不会释放自己的变量对象，只有当闭包执行结束后才会释放，因此闭包将会占用更大的内存空间，用于存储外层函数的变量兑现

因此，能避免的情况下就不要使用闭包
```

```javascript
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

var add = makeAdder;
console.log(add(5)(2));		// 7
add = null;					// 使用完后，防止内存溢出
```

**读取内部函数变量**

```javascript
function m1(){
    var a = 100;
    return function m3(){
        console.log(a++);
    }
}
var _m3 = m1();		

function m2(){
    _m3();
}

// 因为_m3是全局变量，因此m2可以调用_m3
// 等价于m2间接的，读取到了m1的内部函数变量a，m3就是闭包函数
```

**闭包的特点闭包访问外层函数变量的特点：**

- 若闭包在外层函数执行结束后执行，那么它只能获取到外层函数中所有变量的最终状态

```javascript
function father(){
    var array = [];
    for (var i=0; i<10; i++) {
        array[i] = function(){	// 只看以这一步
            return i;            
        }
    }
    return array;
}

// 打印操作
var foo = father()
for(var i=0;i<foo.length;i++){
    console.log(foo[i]())
}
// 10 10 10 10 10 10 10 10 10 10


// father函数执行后会返回一个包含闭包的数组，每个闭包都会返回i
// 由于这里的闭包调用时，外层函数早就执行结束了，外层函数变量对象中i值已经变成了10，此时不管执行array中的哪个闭包，返回的结果都是10
// 道理很简单， array[i] = function(){}是只是声明了一个函数，而函数具体返回的值是在调用后决定的，函数真正的调用是在console.log(foo[i]())，调用时的i是全局变量，由循环机制可知，只会取到最后一个值
```

可以改写：

```js
// 方式一：改用let
function father(){
    var array = [];
    for (let i=0; i<10; i++) {
        array[i] = function(){	// 只看以这一步
            return i;            
        }
    }
    return array;	// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
}	

// 方式二：为函数增加形参
function father(){
    var array = [];
    for (let i=0; i<10; i++) {
        array[i] = function(i){	
            return i;            
        }
    }
    return array;	
}

var foo = father()
for(var i=0;i<foo.length;i++){
    console.log(foo[i](i))		// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
}
```

- 在闭包外层函数执行过程中立即执行闭包

```javascript
function father(){
    var array = [];
    for (var i=0; i<10; i++) {
        array[i] = (function(){
            return i;
        })()
    }
    return array;
}

var foo = father()
console.log(foo)	// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]

// 此时的闭包在外层函数执行时就立即执行，在那个时刻，闭包中i的值就是外层函数当前i的值，因此返回的array中存储的将是0-9
```

- 两者合并改造（使其能正常返回，且返回的不是执行结果而是闭包函数）

```javascript
function father(){
    var array = [];
    for (var i=0; i<10; i++) {
        array[i] = (function(){
            var curI = i;
            return function(){
                return curI;
            }
        })();
    }
    return array;
}


var foo = father()
 for(var i=0;i<foo.length;i++){
    console.log(foo[i]())
 }
// 0 1 2 3 4 5 6 7 8 9


// 立即执行的闭包再返回一个闭包，并且将for循环中的i值赋给立即执行函数的局部变量，此时array中存储的将是闭包，并且每个闭包都拥有正确的值
```

**闭包与内存泄漏**

闭包中涉及DOM对象可能会出现内存泄漏

```
JavaScript由ECMAScript、BOM、DOM组成，在某些浏览器中他们使用不同的语言实现，因此他们具有不同的垃圾回收机制。 ECMAScript对象采用标记清除算法回收内存，而某些浏览器的DOM对象采用引用计数算法回收内存。引用计数有个致命的缺点——无法回收循环引用的对象

举个例子：如果一个DOM对象A中的属性a指向另一个DOM对象B，而B中有属性b指向对象A，那么这两个对象存在循环引用，垃圾回收机制就无法回收他们，这就造成了内存泄漏。 
```

只要循环引用的两个对象中存在一个DOM对象，就会导致内存泄漏

```javascript
function func () {
    var dom = document.getElementById("xx");
    dom.onclick = function(){
        alert(dom.id);
    }
}

// 获取了一个DOM对象
// 让这个对象的onclick属性指向了一个JS函数对象；而这个函数对象又指向了DOM对象的id属性，从而出现了循环引用
// 由于这两个对象中存在一个DOM对象，因此就会出现内存泄漏
```

解决方案：破坏两个对象的相互引用

```javascript
function func () {
    var dom = document.getElementById("xx");
    var id = dom.id;
    dom.onclick = function(){
        alert(id);
    }
}

// 要为dom添加一个点击事件，因此dom.onclick属性必须要指向一个JS函数对象，因此这个引用不能切断。
// 第二个引用是由JS函数对象指向DOM对象的，目的是为了获取dom的id，可以通过上面代码切断这个引用
```

----

#### this指向

##### 一般函数

**this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁**，**实际上this的最终指向的是那个最后调用它的对象**

- 一般的函数调用对象this指向Window

```javascript
function a(){
    var user = "lucy";
    console.log(this.user); 
    console.log(this); 
}
a();
//undefined
//Window

window.a();		// 和直接执行a()完全一样
//undefined
//Window
```

- 调用对象里的函数this指向对象

```javascript
var o = {
    user:"lucy",
    fn:function(){
        console.log(this.user);  
        console.log(this);
    }
}
o.fn();
// lucy
// { user: 'lucy', fn: [Function: fn] }   （下面简写为对象名）
```

```javascript
var O = {
    o:{
        user:"lucy",
        fn:function(){
            console.log(this.user);  
            console.log(this);
     	}		
    }
}
O.o.fn();
// lucy
// 对象o	最近原则
```

- this只会指向它的上一级对象，不管这个对象中有没有this要的东西

```javascript
var o = {
    a:10,
    b:{
        fn:function(){
            console.log(this.a); 
        }
    }
}
o.b.fn();	//undefined
// 这里this指向b，因此为b.a为undefined
```

- 函数赋值情况

```javascript
var o = {
    b:{
        fn:function(){
            console.log(this); 
        }
    }
}
var j = o.b.fn;		// 注意不是o.b.fn() 这里函数还是没有执行的
j();	// window
// 使用j去接收了fn函数，即最后实际上等于window.fn()
```

- 使用new关键字时，this指向实例对象（构造函数没有return对象时）

```js
function fn() {  
    this.user = 'lucy';  
}
var a = new fn();  
console.log(a.user); // lucy
```

- 函数中有return的情况

  返回值为对象（函数也是一个对象）时，即使对象为空，this指向返回的那个对象

```javascript
function fn()  
{  
    this.user = 'lucy';  
    return {user:'jack'};	
}
var a = new fn();    // 实际上就是返回了一个对象给a，那a.user自然是取自这个对象里的
console.log(a.user); // jack
```

​		返回值不是对象时，this指向不变（null是一个特殊对象，返回null时this指向也不变）

```javascript
function fn()  
{  
    this.user = 'lucy';  
    return 1;
}
var a = new fn;  
console.log(a.user); //lucy
```

```javascript
function fn()  
{  
    this.user = 'lucy';  
    return undefined;
}
var a = new fn;  
console.log(a.user); //lucy
```

**总结：**

```
情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window
情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象
情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象
```



----

##### 箭头函数

**箭头函数和普通函数的区别：**

- 是匿名函数，不能作为构造函数，不能使用new
- 没有原型属性

- 不绑定arguments，取而代之用rest参数
- 不能当做Generator函数,不能使用yield关键字
- 不绑定this，会捕获其所在的上下文的this值，作为自己的this值，箭头函数的 this 永远指向其上下文的  this ，任何方法都改变不了其指向，如  `call()，bind()，apply()` ，调用时只相当于传入参数

```markdown
普通构造函数通过new实例化对象时this指向实例化对象，箭头函数无法使用用new实例化对象，也不拥有原型prototype
箭头函数也没有argument对象属性，只能通过rest实现
```

箭头函数不会产生this，若函数内有this，则this只能由父级函数继承而来，并不是谁调用指向谁，要看父级函数的this指向，追踪到最近的一个父级this，不会再往上寻找

```jsx
var x = 111
var A = {
    x: 222
    B: {
    	x: 333,
    	C: function f() {
            var D = {
                x: 444,
                say: () => {
                    console.log(this.x)
                }
            }
            D.say()
        }
	}
}
A.B.C()		// 箭头函数this往上找，this从f()传来，由B调用的C，因此f()的this指向B，因此this.x = B.x = 333
```

```jsx
var x = 111
var A = {
    x: 222
    B: {
    	x: 333,
    	C: f = () => {
            var D = {
                x: 444,
                say: () => {
                    console.log(this.x)
                }
            }
            D.say()
        }
	}
}
A.B.C()		// 箭头函数this往上找，找不到function传来的this，因此this.x = Wiondow.x = 111
```

```jsx
var x = 111
var A = {
    x: 222,
    B: {
    	x: 333,
    	C: function f_a() {
            var D = {
                x: 444,
                say: function f_b() {
                    console.log(this.x)
                }
            }
            D.say()
        }
	}
}
A.B.C()		// 不是箭头函数时，this指向最后调用者，因此this.x = D.x = 444
```

箭头函数如果想简单返回一个对象的时候，可以使用下面这种写法

```js
const demo = () => ({a:1})

// 等价于
const demo = () => {
    return {a: 1}
}

```



---

### Event Loop

```
博客：https://segmentfault.com/a/1190000016278115
运行机制视频：https://www.bilibili.com/video/BV1kf4y1U7Ln
```

javascript的一个特点就是单线程，但是很多时候需要在不同的时间去执行不同的任务，例如给元素添加点击事件，设置一个定时器，或者发起Ajax请求，因此需要一个异步机制来达到这样的目的，事件循环机制（Event Loop） 也因此而来

由于JS是一个单线程语言，如果某个任务很耗时，比如涉及很多I/O（输入/输出）操作，那么线程的运行大概是下面的样子，绿色部分是程序的运行时间，红色部分是等待时间，可以看到，由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果，这种运行方式称为 `同步模式 ` 或 `堵塞模式`，事件循环机制用于解决这个问题

<img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013102002.png" style="float:left;width:350px">



事件循环机制是一个程序结构，用于等待、发送消息和事件：

程序中有两个线程，一个负责程序本身运行，称为主线程，一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为 Event Loop线程，绿色部分，表示运行时间，而橙色部分表示空闲时间，每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间，等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务

<img src="http://www.ruanyifeng.com/blogimg/asset/201310/2013102004.png" style="float:left;width:350px">

注意，Event Loop相当于只是在运行的时候加下了异步任务的需要执行顺序，等到同步完成后才开始去执行记录的异步任务并返回

```js
// 如这个写文件方法，当启动该方法时，写的过程会放置在Event Loop线程中执行，主线程继续干别的事情，当写完后会触发回调函数，回调函数在主线程内执行
fs.writeFile('t.txt','写入文件的内容',function(err){        
    if(err){
        console.log(err);
        return false;
    }
    console.log('写入成功');
})
```

由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为 `异步模式` 或 `非堵塞模式`

----

**原理**

事件循环机制相关知识：

- 执行上下文
- 函数调用栈
- 队列（数据结构）

通常情况下，决定代码运行顺序的是函数调用栈，但是当有异步代码块，如 `setTimeout` 时，便很难再用函数调用栈去解释，栈的调用顺序是后进先出，而事件循环控制任务顺序使用的是队列，先进先出，即同步的代码块使用执行栈的规则执行，而异步代码块则通过队列来执行

可以把事件循环想象成一个调用栈，一个微任务队列，一宏任务队列，将异步任务推入执行栈时，不会立即执行，而是把异步任务的执行代码块放入宏任务或者微任务队列中，然后执行栈弹出异步任务，往下执行代码放入新的任务进执行栈，如此循环，等到执行栈中任务已经完全清空时，再将微任务按照队列顺序放入执行栈中执行并弹出，微任务队列完全清空时，放入宏任务执行

```
实际上就一句话：先执行完同步代码块，然后执行微任务，最后执行宏任务
```

<img src="https://img-blog.csdnimg.cn/20201119124726275.png" style="float:left;width:350px">

下面代码的时间循环操作顺序：

1. 执行栈`var p = new Promise` 放入执行后弹出
2. 执行栈放入 `console.log(1)` 执行，打印1后弹出
3. 执行栈放入 `fun2()` 执行
4. 执行栈放入 `setTimeou函数` 执行，将 `console.log(6)` 放入宏任务队列，弹出 `setTimeou函数`
5. 执行栈放入 `fun1()` 执行
6. 执行栈放入 `console.log(2)` 执行，打印2后，执行栈依次弹出 `console.log(2)` ，`fun1()`
7. 执行栈放入 `console.log(3)` 执行，打印3后弹出
8. 执行栈放入 第一个`p.then` 执行，将 `console.log(resolve)` 放入微任务队列后弹出 `p.then`
9. 执行栈放入第二个 `p.then` 执行，将 `console.log(5)` 放入微任务队列后，依次弹出 `p.then`，`fun2()`此时执行栈可执行代码已完全清空，开始将微任务队列代码放入执行栈
10. 执行栈放入`console.log(resolve)`执行，打印4后弹出
11. 执行栈放入`console.log(5)`执行，打印5并弹出，此时微任务队列已清空，开始将宏任务队列代码放入执行栈
12. 执行栈放入 `console.log(6)` 执行，打印6并弹出，清空宏任务队列，此时代码完全结束

```js
// 打印顺序 1 2 3 4 5 6
var p = new Promise(resolve => {
    console.log(1)
    resolve(4)
})

function fun1() {
    console.log(2)
}

function fun2() {
    setTimeout(() => {
        console.log(6)
    })
    fun1()
    console.log(3)
    p.then(resolve => {
		console.log(resolve)
    })
    .then(() => {
        console.log(5)
    })
}

fun2()
```









----





---

**宏异步**

宏异步（宏队列）—— macrotask，也称为tasks，包括以下内容

- setTimeout
- setInterval
- setImmediate（Node环境独有）
- requestAnimationFrame（浏览器独有）
- I/O
- UI rendering（浏览器独有）

**微异步**

微任务（微队列） —— microtask，也称为jobs，包括以下内容

- Promise
- process.nextTick（Node环境独有）
- Object.observe
- MutationObserver

```js
// 这里需要注意的是，声明promise函数是同步的
console.log(1)

new Promise((resolve, reject) => {
    console.log(2)
    resolve()
}).then(() => {
    console.log(4)
})

console.log(3)
// 打印顺序 1 2 3 4
```

```js
// 不同代码块中的宏任务顺序，打印顺序1，2 
new Promise((resolve, reject) => {
    resolve()
}).then(() => {
    setTimeout(() => {
        console.log(2)
    },0)
})


setTimeout(() => {
    console.log(1)
},0)	// 这里延时如果改成3以上，则打印2，1
```



---



### 同步和异步

- **同步：一次只能完成一件任务（程序的执行顺序与编写顺序是一致的）**

  如果有多个任务，就必须排队，等前面一个任务完成，再执行后面一个任务

- **异步：每一个任务都有一个或多个回调函数（callback）（程序的执行顺序与编写顺序是不一致的，可理解为按时间轴执行）**

  前面一个任务结束后，不是执行后一个任务，而是执行回调函数

  后一个任务则不是等前一个任务结束就执行

**JS实现异步的原理：**

JS是单线程语言，但是js的宿主环境（浏览器，Node）是多线程的，所以js具备了异步的属性

```
浏览器的内核是多线程的，他们在内核制控下相互配合以保持同步
一个浏览器至少实现三个常驻线程 —— JS引擎线程、UI渲染线程、浏览器事件触发线程:
	· JS引擎线程是基于事件驱动单线程执行的，一直等待着任务队列中任务的到来，然后加以处理，因此浏览器无论什么时候都只有一个JS线程在运行JS程序
	· UI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或者由于某种操作引发回流（reflow）时，该线程就会被执行（UI渲染线程与JS引擎是互斥的 当JS引擎执行时UI线程会被挂起 UI更新会被保存在一个队列中等到JS引擎空闲时立即被执行）
	· 事件触发线程，当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎处理（这些事件可来自JS引擎当前执行的代码块如setTimeOut 也可来自浏览器内核的其他线程如鼠标单击、AJAX异步请求等 但是由于JS的单线程关系所有这些事件都得排队等待JS引擎处理）
```

总结：当JS触发到异步任务时，会将异步任务交给浏览器进行执行，当执行有结果时会把异步任务的回调函数插入待处理队列的队尾 JS的工作机制是当线程空闲（所有同步任务执行完毕）后才会执行异步代码的回调（即使setTimeOut设为延时0ms执行也是异步操作）

**Ajax发送异步请求浏览器做了什么：**

1. JS创建了一个ajax请求
2. 浏览器另外开启了一个ajax引擎线程，执行ajax请求
3. 执行得到响应后将回调函数放入任务队列中
4. JS执行任务队列中的回调函数

**常见的异步：**

- 点击事件

  ```
  浏览器处理点击事件过程：浏览器开启事件触发线程，等待用户动作，事件触发线程解析为响应事件，转移到JS引擎线程，排队等候等待JS引擎处理
  ```

- Ajax请求

- 定时器

- 操作文件

- 建立网络连接

- 请求数据库服务

- 读取网络流数据

**例用程序：**

```js
// setInterval为异步执行函数
console.log('1');

setInterval(() => {
    console.log('2');
}, 100);

setInterval(() => {
    console.log('4');
}, 20);

console.log('3');
// 输出结果：1 3 4 4 4 4 4 2 4 4 4 4 4 2 4 ………

/*
	异步，会等同步的步骤按编写顺序执行完后再开始执行异步的操作，遇到异步操作会默认跳过
	因此等输出1和输出3的代码执行完后，才开始执行异步操作
	输出2为每20ms执行一次，输出'4'为每100ms输出一次，异步操作按时间轴来看（并不按照代码顺序）所以等同步操作执行完后开始算计时
	第一次走到20ms时 输出'4' 然后随着时间走到 40ms 60ms 80ms 100ms时 都会输出'4'，同时100ms时，输出2的程序开始启动，所以就会形成每输出5次'4'输出1次'2'的情况
	
	注意：若一个函数里面同时存在同步操作和异步操作，执行函数的时候，还是会先执行完同步代码块，然后再按顺序执行异步代码块
```

异步单线程：

```javascript
// A.js文件
var B = require('B.js');

console.log('A-同步一');

setTimeout(() => {
    B.B();
    console.log('A-异步一')
    
}, 0);

console.log('A-同步二');
```

```javascript
// B.js文件
exports.B = function(){
    console.log('B-同步');
    
    setTimeout(() =>{
        console.log('B-异步');
    },0)
}
```

```
执行A文件，返回结果：
A-同步一
A-同步二
B-同步
A-异步一
B-异步
```

将A、B文件改成：

```javascript
// A.js文件
var B = require('B.js');

console.log('A-同步一');

setTimeout(() => {
    B.B();
    console.log('A-异步一')
    
}, 0);

setTimeout(() => {
    while(true){
        console.log('A-异步二')
    }   
},10)

console.log('A-同步二');
```

```javascript
// B.js文件
exports.B = function(){
    console.log('B-同步');

    setTimeout(() => {
        console.log('B-异步二')
    },11)

    setTimeout(() =>{
        console.log('B-异步一');
    },0)

}
```

```
执行A文件：
A-同步一
A-同步二
B-同步
A-异步一
B-异步一
A-异步二
A-异步二
A-异步二
……
（死循环）
```

由此可知，虽然异步有一种多线程的感觉，但是实际上在运行的永远只有一个程序，即——JS是单线程语言

异步代码的执行步骤可看作是由一段时间轴来控制，但是即使命令多个任务在同一时间执行，也只能执行完一个再开始另一个（多线程），时间轴确定他们排队顺序（队伍只有一条），然后按排队顺序执行

```javascript
console.log('同步一');

setTimeout(() => {
    console.log('异步一-延时0s')
    
}, 0);

setTimeout(() =>{
    setTimeout(() =>{
        console.log('内层异步-延时5s')	// 实际上等于 10+5=15s
    },5)
    console.log('外层异步-延时10s')
},10)

setTimeout(() => {
        console.log('异步-延时10s')
},10)

setTimeout(() => {
        console.log('异步-延时14s')
},14)

setTimeout(() => {
    console.log('异步-延时16s')
},16)

console.log('同步二');

/*
同步一
同步二
异步一-延时0s
外层异步-延时10s
异步-延时10s
异步-延时14s
内层异步-延时5s
异步-延时16s
*/
```







---

### 特殊函数

#### 高阶函数

高阶函数是至少满足下面一个条件的函数：

- 接收一个或多个函数作为参数
- 返回一个函数

```javascript
var add = (x) => {
	return (y) => {
		return x + y
	}
}

add(1)(2)  // 3
```

----

#### 回调函数

函数A作为参数传递到了函数B中，在B中A被执行了

回调函数是闭包函数

回调可以是同步也可以是异步

一般回调函数都用在耗时操作上面，比如ajax请求，处理文件等

```{javascript
function callback(str){
    console.log('回调函数执行'+str)
}

function main(x,callback){
    console.log(x);
    callback(x)
    console.log(x)
}

main('测试',callback)

// 测试
// 回调函数执行测试
// 测试
```

**使用回调函数处理异步操作的数据**

```javascript
var str = '未写入'

function f(str) {
    console.log(str)
}
 
function writeFile() {
    fs.writeFile('input.txt', '写入内容', function (err) {
        if (!err) {
            str = '写入完毕'
        }
    });
}
 
writeFile()
f(str)

// 要求：写入完成后，更改str的状态，使其打印‘写入完成’，然而实际运行中，由于fs.writeFile是异步操作，因此会先执行f(str)，所以会打印'未写入'，无法满足要求
```

在在异步函数中直接调用函数：

```javascript
var str = '未写入'

function f(str) {
    console.log(str)
}
 
function writeFile() {
    fs.writeFile('input.txt', '写入内容', function (err) {
        if (!err) {
            str = '写入完毕'
            f(str)
        }
    });
}
 
writeFile()

// 可以满足要求，但是写死了，如果不执行f()而执行其他函数又要重新变动，麻烦
```

使用回调函数：

```javascript
var str = '未写入'

function f(str) {
    console.log(str)
}
 
function writeFile(callback) {
    fs.writeFile('input.txt', '写入内容', function (err) {
        if (!err) {
            str = '写入完毕'
            callback(str)
        }
    });
}
 
writeFile(f)

// 使用回调函数，能满足要求，且十分灵活
```

大多数情况里，使用的回调函数一般会写成匿名函数：

```javascript
var str = '未写入'

function writeFile(callback) {
    fs.writeFile('input.txt', '写入内容', function (err) {
        if (!err) {
            str = '写入完毕'
            callback(str)
        }
    });
}

// 最常见的使用方法
writeFile(function(str){
	console.log(str)
})
```



----



### 原型链

#### 基础

构造函数创建对象：

```javascript
function Person() {

}
var person = new Person();
person.name = 'mary';
console.log(person.name) // Kevin

// Person 就是一个构造函数，使用 new 创建了一个实例对象 person
```

**prototype**

每个函数都有一个 prototype 属性

每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个关联对象即 `原型`，每一个对象都会从原型中”继承“属性

为了方便理解，用面向对象的思路去思考，将Person函数理解为类，将实例化person理解为对象，只有类拥有`prototype`属性，而对象没有

```javascript
function Person() {

}

// prototype是函数才会有的属性
Person.prototype.name = 'Kevin';
Person.prototype.age = '24';
Person.sex = 'boy';

var person1 = new Person();		// 实例化
var person2 = new Person();

console.log(person1.name)       // Kevin
console.log(person2.age)        // 24	每一个成员都会继承原型中的所有属性
```

<img src="https://img-blog.csdnimg.cn/20200505181123401.png" style="float:left">

**proto**

每一个JavaScript实例对象(除了 null )都具有的一个属性`_proto_`，这个属性会指向该类的原型

```javascript
function Person() {

}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true  实例化对象的proto属性等于原型
```

<img src="https://img-blog.csdnimg.cn/20200505181337357.png" style="float:left">

**constructor**

每个原型都有一个 constructor 属性指向关联的构造函数，实例原型指向构造函数

```javascript
function Person() {

}
console.log(Person === Person.prototype.constructor); 	// true
```

<img src="https://img-blog.csdnimg.cn/2020050518111197.png" style="float:left">

图里没画上的线路：对象person可通过``constructor``得到类Person

**原型、类、对象** 

`原型`

可理解为该类拥有的属性，若一个类想要操作一个属性，不能直接进行操作，必须通过原型来进行（函数对象里声明的变量不是属性），`即原型、类、对象的关系可以进一步缩减理解为类和对象之间的关系，原型只是对象拥有的属性，类和对象能通过一些方法（prototype、proto）来访问到这个属性`

```javascript
function Person() {

}
Person.prototype.name_ = 'Kevin';		// 通过原型设置属性
Person.sex = 'boy';						// 设置类的静态属性

console.log(Person.prototype)			// Person { name: 'Kevin'}
console.log(Person.sex)					// boy	
console.log(Person.name_)				// undefined	说明通过原型设置的属性无法通过静态取得
console.log(Person.prototype.name_)		// Kevin			
```

`类`

声明对象功能并实例化一个对象

`对象`

每一个对象都拥有类的全部功能，当然也可拥有类的属性，而类的属性存放在原型，通过原型进行操作，因此当对象要拿到类属性，只能在原型中拿（当对象中添加了同名属性时，优先度对象＞类），当对象中找不到指定属性时，才会往上层寻找

```javascript
function Person() {

}

Person.prototype.name = 'Kevin';

var person = new Person();

person.name = 'Daisy';
console.log(person.name) 	// Daisy

delete person.name;			// 删除成员person中刚添加的name属性
console.log(person.name) 	// Kevin
```

**对象、类、原型、Object之间的关系**

```javascript
Object.prototype.age = '24';

function Person() {

}

var person = new Person();
Person.prototype.age_ = '23';

console.log(Person.prototype);   		// Person { age_: 23 }
console.log(Person.prototype.age) 	 	// 24
console.log(Person.age);         		// 24 之前例子得知设置原型的属性无法从该类静态属性中取得，这里是顺着原型链往上取
console.log(person.age_);        		// 23
```

<img src="https://img-blog.csdnimg.cn/20200505181114954.png" style="float:left">



```
可以分为两条链路理解：
Object原型 → Object类 → Object对象（Object成员即其他对象的原型）
原型 → 类 → 对象

这样的好处就是只需要记住原型、类、对象的关系三者之间固有的关系即可（加上记住其他类原型即Object三者关系中的对象）
```

**完整的原型链**

Object为最顶层的原型，因此Object的原型为null

<img src="https://img-blog.csdnimg.cn/20200505181118419.png" style="float:left">

**实例可以直接找到原型中的属性，而构造函数不行**

```jsx
function Test () {

}

Test.prototype.names = 'lucy'

const test = new Test()

console.log(Test.names)             // undefined
console.log(test.names)             // lucy
console.log(Test.prototype.names)   // lucy

Test.names = 'jack'                 // 创建静态属性
console.log(Test.names)             // jack
```



-----

#### new

使用new操作符创建对象实例时发生的事情：

1. 创建一个新对象
2. 将构造函数的作用域赋给新对象（this指向该对象）
3. 执行构造函数的代码（因此构造函数中使用this声明的属性和方法会复制给新对象）
4. 返回新对象

```jsx
function Person() {
    this.name = 'lucy'
    const age = 12
}

const person = new Person()
// 等同于
const person = new Object()
person.name = 'lucy'	// 没有this声明的属性不会进行赋值

// 可以理解成，因为有this的存在，new的时候this实际是person，执行一遍构造函数就是this.name = 'lucy' 等同于 person.name
// 因此person里就有了name对象
```

任何函数，只要通过new操作符来调用，那么它就可以作为构造函数；任何函数，如果不通过new操作符来调用，那它与普通函数并无区别



----

#### 继承

**主要实现思想：**

- 将父实例作为子构造函数的原型

  这样子实例就能顺着原型链找到上级的原型使用到Father原型的属性和方法（实例化子类时，优先调用的是父类的构造函数，因此实际上实例`constructor`的结果是父类构造函数，但是执行的是子类构造函数中的方法）

```jsx
function Father() {
	this.age = 12
    this.action = function() {}
}
function Child() {
	console.log('执行子类构造方法') 
}

Father.prototype.name = 'lucy'

Child.prototype = new Father()			// 最关键一步：父类实例 = 子类原型			
const child = new Child()				// 执行子类构造方法

console.log(child)						// Father {}  优先调用父类构造函数，执行子类构造函数的方法，因此是Father类型，子类构造函数无this传递内容，因此内容为空
console.log(child.name)                 // lucy，说明子类成功寻找到父类的原型链属性
console.log(child.constructor)          // [Function: Father]	优先调用父类构造函数，所以没有返回子类的构造函数
console.log(child.__proto__)            // Father {}
console.log(child.__proto__.__proto__)  // Father { name: 'lucy' }

```

注意，如果构造函数中没有使用`this` 声明的属性，使用new关键字构造出来的实例是没有这个属性的，因此想要向外暴露的属性必须用this声明，在new的过程中，this指向实例，相当于在实例中创建了这个属性

```js
function Person() {
    this.name = 'lucy'
    action = function() {}
}
const  person = new Person()
console.log(person.name)		// lucy
console.log(person.action)		// undefined
```

然而在执行`子类原型 = 父类实例` 操作时，是将父类构造函数中this的属性和方法传到子类的原型中而非实例，实例自身找不到该属性和方法时可以顺着原型链往上找到原型中的属性和方法，子类实例中是没有这些属性的

```jsx
function Person() {
    this.name = 'lucy'
    this.action = function() {}
}

function PersonChild() {
    
}

PersonChild.prototype = new Person()		    
const person = new PersonChild()

console.log(person)             				// Person {}
console.log(person.__proto__)   				// Person { name: 'lucy', action: [Function] }
console.log(person.hasOwnProperty('name'))		// false
```



<img src="https://img-blog.csdnimg.cn/20200513104007813.png" style="float:left">

- 在子类的构造函数中使用更改this指向，这样在new一个子类实例的时候，执行子类构造函数方法，调用`Person.call(this, name, age)`，this指向子类，因此会在子类实例中创建父类`this`暴露的属性

```jsx
function Person(name, age) {
    this.name = name
    this.age = age 
    this.info = function() {
        console.log(name, age)
    }
}

function PersonChild(name,age) {
    Person.call(this, name, age)	// 执行一遍Person构造函数的方法，在new实例时this指向实例，因此相当于给子实例设置了一遍父类的this属性和方法，因此子类实例拥有了父类构造函数中的属性方法
}

PersonChild.prototype = new Person()
const person = new PersonChild('lucy',12)	

console.log(person)     // Person { name: 'lucy', age: 12, info: [Function] } 
person.info()           // lucy 12
```



-----

- **原型链继承**

优点：能通过`instanceOf`和`isPrototypeOf`的检测，因为构成了原型链

缺点：无法继承父类构造函数中想要`public`的属性，因为子类内不用`call(this,xxx)`初始化，`PersonChild.prototype = new Person()`不会在子类原型中创建相应属性，子实例就无法通过原型寻找到该属性

使用情况：

```jsx
function Person(name, age) {
    this.name = name
    this.age = age 
    this.run = function() {
        console.log(`${name}, ${age}`)
    }
}
Person.prototype.sex = '男'
Person.prototype.obj = {x:1}

function PersonChild(name, age) {
    this.name = name
    this.age = age
}

PersonChild.prototype = new Person()		    // 将实例作为PersonChild的原型	
const person = new PersonChild('张三', 20)

person.run()                                    // undefined, undefined（没有读取到父类构造函数中的属性）
console.log(person.sex)                         // 男（可以继承原型链的属性）
          
person.__proto__.__proto__.sex = '女'           // 通过子类实例修改原型方法
const person_ = new PersonChild('李四',30)
console.log(person_.sex)                        // 女（因为原型被修改了，新的实例本身没有sex属性，从原型里找，找到被修改后的sex属性）


const per = new Person()
console.log(person.constructor)                 // [Function: Person]
console.log(person.__proto__)                   // Person { name: undefined, age: undefined, run: [Function] }（因为没有直接使用Person构造函数，因此undefined）
console.log(person.__proto__.__proto__)         // Person { sex: '女', obj: { x: 1 } }
console.log(per.__proto__)                      // Person { sex: '女', obj: { x: 1 } }    

console.log(person instanceof PersonChild)		// true
console.log(person instanceof Person)			// true
```

<img src="https://img-blog.csdnimg.cn/20200512221610525.png" style="float:left">

----

- **（借用构造函数）对象冒充实现继承**

优点：创建子实例的时候，父类构造函数里`this`的属性会在子实例中复制一遍

缺点：子实例无法通过原型共享原型属性

```jsx
function Person(name, age) {
    // 构造函数里的方法和属性
    this.name = name
    this.age = age 
    this.run = function() {
        console.log(`${this.name}, ${this.age}`)
    }
}

Person.prototype.sex = '男'


// 对象冒充实现继承
function PersonChild(name, age) {    
    Person.call(this, name, age)   
}

const person = new PersonChild('张三', '20')
person.run()	// 张三 20
console.log(person.sex)     // undefined
console.log(person instanceof PersonChild)		// true
console.log(person instanceof Person)			// false
```

---

- **组合继承（借用构造函数+原型链）**

优点：继承两者优点

缺点：两次调用父类构造函数，浪费内存，而且父类构造函数实际上没必要和子类原型产生联系

```jsx
function Person(name, age) {
    this.name = name
    this.age = age 
    this.run = function() {
        console.log(`${name}, ${age}`)
    }
}
function PersonChild(name, age) {    
	Person.call(this, name, age)
}

PersonChild.prototype = new Person()

const person = new PersonChild('lucy', '20')
```

----

- **原型式继承**

使用场合：没必要构建构造函数，仅仅是想模拟一个对象的时候

```jsx
// 传进一个需要被继承的父对象，将父对象绑定为构造函数的原型，这样实例就能通过原型找到父对象属性
function createChild(Father){
    function Child() { 
       
    };
    Child.prototype = Father
    return new Child()  // 传回一个实例
}
var Father = {
    name: 'jack',
    friends: 'mary'
};

const child = createChild(Father);
console.log(child.__proto__)    // { name: 'jack', friends: 'mary' }
console.log(child.name)         // jack
console.log(child)              // {} 只是一个空对象，主要属性从原型里拿
```



----

- **寄生继承**

缺点：方法在函数中定义，无法得到复用

```jsx
// 创建一个仅用于封装继承过程的函数，传入一个对象，为对象增加特定的一些属性或方法，然后再将改动的对象返回，这样执行过这个方法的对象都会拥有新增的属性和方法
function createAnother(original){
    var clone = Object.create(original)       // 令clone.__proto__ = original 这样clone的属性如果自身找不到就从原型original上获取
    
    clone.sayHi = function(){ 
       console.log("hi");
    };
    
    console.log(clone)     // {name: 'jack', friends: 'mary', sayHi: [Function]}
    return clone; 
}

var person = {
    name: "jack",
    friends: 'mary'
};

const anotherPerson = createAnother(person);
anotherPerson.sayHi()	// 即增加了sayHi这个方法
```

----

- **寄生组合继承(最理想)：**

最理想的原因（对比组合继承）:

1. 只调用了一次父类构造函数，不需要重复new操作
2. 父类的构造函数和子类原型是没必要有联系的，寄生组合切断了这种联系，减轻原型链

```jsx
function createChild(childFun, fatherFun){
    childFun.prototype = Object.create(fatherFun.prototype)	// 使用这个方法就少了new Father去创建实例的操作
    childFun.prototype.constructor = childFun				// 双向绑定
}

function Father(name){
    this.name = name 
}

Father.prototype.attribute = '这里是父类的原型属性'

function Child(name, age){
    Father.call(this, name)
    this.age = age
}

createChild(Child, Father)  //实现继承

const child = new Child('mary',12)
console.log(child)                          // Child { name: 'mary', age: 12 }
console.log(child.constructor)              // [Function: Child]  因为没有直接与父类构造函数绑定，因此构造函数的类型为Child而不为Father
console.log(child.__proto__)                // Child { constructor: [Function: Child] }
console.log(child.__proto__.__proto__)      // Father { attribute: '这里是父类的原型属性' }
```

`createChild()`方法内部干的事情

<img src="https://img-blog.csdnimg.cn/20200514213118280.png" style="float:left">

如果上面代码不使用双向数据绑定的方式，结果会有所不同，说明以这种方式去绑定原型链时，如果不绑定子类构造函数和原型的双链关系，子类的实例和构造函数会链接上父类，等于缺失了子类构造函数这条链路

```js
function createChild(childFun, fatherFun){
    childFun.prototype = Object.create(fatherFun.prototype)
}
...
const child = new Child('mary',12)
console.log(child)                          // Child { name: 'mary', age: 12 }
console.log(child.constructor)              // [Function: Father]
console.log(child.__proto__)                // Father {}
console.log(child.__proto__.__proto__)      // Father { attribute: '这里是父类的原型属性' }
console.log(Child.prototype.constructor)    // [Function: Father]
```

<img src="https://img-blog.csdnimg.cn/202011181732393.png" style="float:left">



-----

**原型链的缺点：**

一个实例操作一个自身没有，但是原型拥有的属性时，如果是值类型，实例会在自身新增该属性并赋值，但是如果是引用类型，会直接修改到原型中

可以用const来复制理解，const是一个常量

```jsx
cosnt num = 1
const obj = {value: 1}

const num = 2 				// 报错
const obj.value = 2			// {value: 2}
```

即理论上原型不允许实例对自身的属性进行修改，如果修改的值类型，因为变量和值都存放在栈中，因此当实例想要修改一个原型中的值类型属性时，会默认在实例自身中进行修改而不是修改原型的，但是如果修改的是原型的引用类型，原型只能判断变量的引用地址有没有发生变化，因此修改引用类型是不会被原型发觉的，且默认在实例中找不到指定属性时便往原型中搜索，因此便直接修改到了原型的引用类型属性而非在实例自身中增加属性

**即：实例想对一个属性进行操作**

- **判断实例中有没有该属性**

- **如果没有，往上寻找原型中是否有**

  - **判断是否是读操作，如果是读操作，则直接读取**

  - **如果是写操作，则默认不可写，不会再往上级原型寻找，退回并实例中创建并写入该属性**

```jsx
const Prototype =  {
	num : 1,
	obj : {
		value : 1
	},

}

const Instance = Object.create(Prototype)


console.log(Instance)			// { }
console.log(Instance.num)		// 1  
console.log(Instance.obj)		// { value: 1 }


Instance.num = 2				// 修改值类型，发现原型不会改变，实例内部增加属性
console.log(Prototype)			// { num: 1, obj: { value: 1 } }
console.log(Instance)			// { num: 2 }


Instance.obj.value = 2			// 修改引用类型里的值，发现原型属性被更改，实例内部不会增加属性
console.log(Prototype)			// { num: 1, obj: { value: 2 } }
console.log(Instance)			// { num: 2 }


Instance.obj = {value : 3}		// 修改obj的引用地址，发现原型不会改变，实例内部增加属性
console.log(Prototype)			// { num: 1, obj: { value: 2 } }
console.log(Instance)			// { num: 2, obj: { value: 3 } }
```

-----

**如何解决这个问题：**

思路：既然实例写操作非自身属性的引用类型时会更改到原型，那解决方式就是，在实例构造出来的时候，将该引用类型的属性在new实例时在实例中也建一个，这样实例修改该属性时，便会找到自己的修改非原型上的

```jsx
function Father() {
	this.num = 1
    this.obj = {value:1}
}
function Child() {
	Father.call(this)			// 继承时实例要使用call函数的另一种原因
}

// 调用Father(),this指向Child构造函数原型，因此此时会在Child的原型中创建num和obj属性
Child.prototype = new Father()

// 调用Child()，执行Father.call(this)，this指向child实例，因此会在实例中创建num和obj
const child = new Child()				

console.log(child)				// Father { num: 1, obj: { value: 1 } }
console.log(child.__proto__)	// Father { num: 1, obj: { value: 1 } }

child.obj.value = 2				// 实例操作引用类型属性，发现只会更改自己的
console.log(child)				// Father { num: 1, obj: { value: 2 } }
console.log(child.__proto__)	// Father { num: 1, obj: { value: 1 } }
```



---

#### 类和构造函数的区别

**ES5中函数定义类（构造函数）：**

```javascript
function Foo(x,y) {
    this.x = x;
    this.y = y;
}

Foo.prototype.toString = function(){
	console.log(this.x, this.y)  
}

var foo = new Foo(1,2)
foo.toString()  

// 1 2
```

**ES6中定义类：**

调用类的方法也就是调用原型（prototype）上的方法

```javascript
class Foo {   
    constructor(x,y){
     this.x = x;
     this.y = y;
    }
    
    toString(){
     console.log(this.x, this.y)
    }
}

var foo = new Foo(1,2)
foo.toString()  

// 1 2
```

ES6中，class实际上也是一个function对象，其原型链与es6一致，但有几点需要注意

- 类里的``constructor()``方法表示构造函数，与原型链中的`.constructor`属性无关
- 在class中声明的函数会直接添加到原型中，可以直接使用，不需要特意指定原型声明
- 通过new关键字生成实例时，只会执行`constructor`构造函数里的内容

```javascript
class Foo {   
    constructor(x,y){
     this.x = x;
     this.y = y;
    }
    
    toString(){
     console.log(this.x, this.y)
    }

    
}

Foo.prototype.name = 'Jack'
var foo = new Foo(1,2)

console.log(Foo)                            // Function: Foo]
console.log(foo)                            // Foo { x: 1, y: 2 }

console.log(Foo === foo.constructor)        // true    成员访问对象     foo.__proto__.constructor

console.log(Foo.prototype)                  // Foo { name: 'Jack' }     对象访问原型
console.log(foo.__proto__)                  // Foo { name: 'Jack' }     成员访问原型
```

------

**es5的构造函数和静态方法**

```javascript
function Person(name, age) {
    // 构造函数里的方法和属性
    this.name = name
    this.age = age 
    this.run = function() {
        console.log(`${this.name}, ${this.age}`)
    }
}

// 设置原型属性
Person.prototype.sex = '男'
Person.prototype.work = function() {
    console.log('work')
}

// 设置静态方法
Person.setName = function() {
    console.log('静态方法')
}

var person = new Person('张三', '23')
person.run()    // 实例共享原型的属性
person.work()


Person.setName()    // 用构造函数来执行静态方法
```

**ES6里的类和静态方法**

类里直接声明的函数实际上是在原型中进行声明，如果要特地指明静态方法，需要用`static`关键字，这样实际上就是`Person.xxx`直接添加类的一个属性

```javascript
class Person {
    
    say() {
        console.log('实例方法')
    }
    
    static work() {
       	console.log('静态方法')
    }
}

const person = new Person()
person.say()	// 实例内部找不到该方法时，可以通过原型找到该方法并调用
Person.work()	// 静态方法相当于类的一个属性，因此可以通过类来直接调用
```

---

#### 类的继承

- **类中直接定义的方法，实际上是在原型中定义，但是它是隐式的**

```jsx
class Demo {
	classFun() {
        
    }   
}
console.log(Demo.prototype)				// Demo {}
console.log(Demo.prototype.classFun)	// [Function: classFun] 实际上是有的
Demo.prototype.other = 'other'			// 直接通过原型声明的话会显示
console.log(Demo.prototype)				// Demo { other: 'other' }
```

- **使用`extentds`关键字实现继承时，实例化子类时，会执行父类的构造函数` constructor() `方法**

```jsx
class Father {
    constructor() {
		console.log('执行父类构造函数')
		this.fatherAttribute = '这里是父类的属性'
	}
}

class Child extends Father{

	
}

const child = new Child()	// 打印：'执行父类构造函数'
// 相当于实例child去调用了父类的构造函数，this指向child，因此会在child创建 fatherAttribute
console.log(child)		// Child { fatherAttribute: '这里是父类的属性' }
```

- **在一个使用`extentds`关键字实现继承的类中，如果不声明`constructor()`方法，在实例化子类时会默认调用父类的构造方法，但是如果声明了`constructor()`，必须要手动去调用父类构造函数（`super()`），否则子类`constructor()`构造函数会报错**

```jsx
class Father {
    constructor() {
		console.log('执行父类构造函数')
		this.fatherAttribute = '这里是父类的属性'
	}
}

class Child extends Father{
	constructor() {
		super()		// super()表示调用父类的构造函数,声明构造函数而不调用super()会报错
	}	
}
```

- **可以在子类构造函数里使用`super.xxx`去调用父类在原型中声明的方法**

```jsx
class Father {
    constructor() {
		console.log('执行父类构造函数')
		this.fatherAttribute = '这里是父类的属性'
	}

	implicitFunction() {
		console.log('调用父类原型中的隐式方法')
	}
}

Father.prototype.explicitFunction = () =>{
	console.log('调用父类原型中的显式方法')
}

class Child extends Father{
	constructor() {
		super()					 
		super.implicitFunction()	 // 调用父类原型中的隐式方法
		super.explicitFunction()	 // 调用父类原型中的显式方法
	}	
}
```

- **继承在原型链中的关系**：

  **和ES5原型链继承有所不同，类（类也是构造函数）在继承中，子类构造函数的原型不是父类的实例，且`__proto__`指向父类构造函数而非`Function`的原型**

  **父类构造函数的`__proto__`仍指向`Function`原型**

```jsx
class Father {
	constructor(){		// 注明：如果父类中没有声明构造函数，则无法成功被继承

	}
}

class Child extends Father{

}

Child.prototype.pro = '子类原型属性'

const child = new Child()	

console.log(child.constructor == Child)							// true
console.log(child.__proto__.constructor == Child)				// ture					
console.log(child.__proto__.__proto__ == Father.prototype)		// true
console.log(child.constructor.__proto__ == Father)				// ture
console.log(child.__proto__.__proto__.constructor == Father)	// true
console.log(Child.__proto__ ==  Father)							// true
console.log(Child.prototype)									// Child { pro: '子类原型属性' }
```

<img src="https://img-blog.csdnimg.cn/20200515155438139.png" style="float:left">

​		**ES5使用原型链继承中，子类和父类构造函数的`__proto__`都是指向`Function`原型的**

```jsx
function Father() {
	this.num = 1
    this.obj = {value:1}
}
function Child() {
	Father.call(this)			
}

Child.prototype = new Father()
const child = new Child()				
	
Function.prototype.app = 'app'

console.log(Child.__proto__)		// { [Function] app: 'app' }
console.log(Father.__proto__)		// { [Function] app: 'app' }
```



----

#### 类的单例设计

一个类可以生成多个实例，每次`new`的实例都是互不干扰的，单例就是让类生成一个固定的实例

```javascript
class Person {
    
    constructor() {
        this.name = 'lucy'
    }
    
    // 一个静态方法，用于生成一个单例
    static getInstance() {
        if(!Person.instance){   // 如果尚未创建实例，则进行创建，如果存在，则一直返回该实例
            Person.instance = new Person()
        }
        return Person.instance
    }
}
const person = Person.getInstance()		// 注意，这里既然想用一个单例，则就不用new关键字去生成实例了，如果直接使用new还是会生成互不干扰的各个实例

console.log(person.name)	    // lucy
person.name = 'jack'          // 对实例属性进行修改

const person_ = Person.getInstance()
console.log(person_.name)     // jack，可以证明用该方法生成的实例，会返回同一个实例

const personA = new Person()  // 使用new关键字可以创建其他实例，实例间互不干扰
console.log(personA.name)     // lucy
```



----



