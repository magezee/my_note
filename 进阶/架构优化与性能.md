### 开发模式

```
https://www.jianshu.com/p/fcb98533bc18
```

**前后端分离**

目前主流的web开发都是前后端分离的模式，前后端根据AJAX接口进行数据的交互，目前常见的是后端直接将数据以 JSON 的格式返回给前端，前端根据这些数据操作 DOM

主要优点：

- 分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面设计

- 接口明确，并行开发，在后端接口没有实现好之前，前端完全可以自己通过Node框架（如koa）模拟接口，提供测试数据

- 提高开发效率，一定程度上减少了前后端的沟通成本

在前后端分离中，后端一般提供 `RESTful API`，常将数据以JSON格式返回；而前端一般使用以下技术进行开发

---

**SPA**

单页面应用（Single Page Application），是一种网络应用程序模型

顾名思义，整个网站只有一个 `html` 文件，不同的页面只是通过 js 来切换 hmtl 中的内容，`react`，`vue`，`angularJS` 都是那么做的

相比于传统网站不同页面之间的切换都是直接从服务器加载完整一个新页面，SPA 避免了过多数据交互，响应速度会更高

优点：

- 页面之间的切换非常快
- 一定程度上减少了后端服务器的压力（不用管页面逻辑和渲染）
- 后端程序只需要提供API，完全不用管客户端到底是Web界面还是手机等

缺点：

- 首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面
- 不利于SEO

----

**SEO**

搜索引擎优化（Search Engine Optimization），SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名

在 SPA 中，数据主要通过异步 AJAX 获取，而部分搜索引擎（有一些引擎甚至不支持该功能）爬虫虽然可以支持 JS 或者 AJAX 获取数据，但是对异步数据的支持还不足

即如果初始页面使用 loading 动画再通过 AJAX 获取内容，抓取工具并不会等待异步完成后再抓取页面内容，这样真正的数据就不会被搜索引擎抓到了，因此 SPA 难以保证页面可以被搜索引擎正常收录

----

**SSR**

服务端渲染（Server-Side Rendering），在普通的SPA中，一般是将框架及网站页面代码发送到浏览器，然后在浏览器中生成和操作 DOM（这里也是第一次访问SPA网站在同等带宽及网络延迟下比传统的在后端生成HTML发送到浏览器要更慢的主要原因）

但其实也可以将 SPA 应用打包到服务器上，在服务器上渲染出 HTML，发送到浏览器，这样的 HTML 页面还不具备交互能力，所以还需要与 SPA 框架配合，在浏览器上“混合”成可交互的应用程序，所以，只要能合理地运用 SSR 技术，不仅能一定程度上解决首屏慢的问题，还能获得更好的 SEO

优点：

- 更快的响应时间，不用等待所有的 JS 都下载完成，浏览器便能显示比较完整的页面

- 更好的 SEO，可以将SEO的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据。

缺点：

- 相对于仅仅需要提供静态文件的服务器，SSR 中使用的渲染程序自然会占用更多的CPU和内存资源

- 一些常用的浏览器API可能无法正常使用，比如 `window`、`docment` 和 `alert` 等，如果使用的话需要对运行的环境加以判断

- 开发调试会有一些麻烦，因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂

- 可能会由于某些因素导致服务器端渲染的结果与浏览器端的结果不一致

---

**总结**

- 前后端分离降低了前端和后端的耦合度，提高了开发效率
-  SPA是前后端分离中前端的一种解决方案
-  SEO对与很多网站很重要而普通的SPA又不利于SEO
-  SSR的出现一定程度上解决了SPA中首屏慢的问题，又极大减少了普通SPA对于SEO的不利影响



-----

### 性能

性能是衡量架构最基本也是最核心的指标之一

性能包括了技术性能指标和业务性能指标，前者可量化且与业务无关，后者为具体的某个需求的所需指标

Web应用的性能优化主要针对两个方面：

- 输入url后尽可能快地将内容展示给用户
- 提高用户操作的反馈速度和流畅度（如loading动画效果）

----

#### Web性能评估模型

要对比一个Web应用程序的性能，首先需要先确保是一致的客户端场景，包括如下内容

- 设备特征：设备类型（PC/平板/手机）、硬件配置、操作系统、版本等
- 浏览器特征：品牌、版本等
- 网络情况：连接方式（光纤/wifi/4G等）、运营商、地区、带宽等

即如果A、B要想测出一个web的性能，首先A、B需要满足上面情况都是相同的，否则不具有对比性

通过为以上参数赋予固定的值从而将应用限定在一致的客户端场景中，然后再逐指标地进行对比，这是指定性能评估模型的最基础原则

----

##### Web生命周期

Web应用程序的生命周期分为两个阶段：加载阶段、可交互阶段

**加载阶段**

访问url直到浏览器屏幕被网页填充完毕阶段

- 优化目标：

  令浏览器尽可能快地完成网站初始状态（首屏）的呈现，给用户留下良好的第一印象

- 优化方向：

  从视觉角度提高网站内容的渲染速度 —— 对应白屏时间和首屏时间两项指标

  从交互角度缩短从打开网站到可交互之间的时间间隔 —— 对应可交互节点指标

```markdown
白屏时间
	从输入url直到将有可视化图像被渲染到浏览器视窗中的那一刻
	这期间浏览器工作：域名查询→与Web服务器建立TCP连接→发送HTTP请求→接收并渲染响应HTML文档等

首屏时间
	从白屏时间结束→首屏内容全部渲染完毕（也有另外一种说法是首屏时间包括白屏时间）

可交互节点
	网页首次可以响应用户操作反馈的那一刻
	可交互节点代表的是一个时刻而非时间间隔，优秀的设计是将可交互节点在首屏时间结束前达成
```

从业务角度来评估加载性能：

- 首次有效绘制：

  优先级最高的内容被首次渲染的时间节点

  从技术上所有的内容都是平等的，但是从业务上，显示的内容存在优先级，因此应该优先度高的内容相对更早的展示给用户

- 广告可视节点：

  字面意思

**可交互阶段**

首屏内容全部加载完成后进入可交互阶段，此阶段最能体现一款产品在架构和交互方面独到的设计，性能至关重要；可交互阶段是动态的，可称为动态性能，衡量其性能也是从动态角度出发

- 反馈速度：

  尽可能快地响应用户的操作（如首屏之外内容按需加载）

- 动画帧率

----

#### 优化

##### 网络

优化策略：

- 压缩文件体积
- 合并小体积文件，使用雪碧图和字体图标
- 避免不必要的下载
- 合理使用缓存
- 按需加载

---

##### 遍历性能

当遍历一个对象或者数组时，有以下方法：

支持对象也支持数组：

- for in

支持数组和数组对象：

- Array.prototype.map
- Array.prototype.every

只支持数组：

- for
- while
- forEach

**运行效率如下：**

`for、while` > `forEach、map、every` > `for in`

因此性能最佳的是for或者while，如果要遍历对象时



---

### 内存管理

#### GC算法

GC领域的专业术语：

- 对象：一个供应用程序使用的数据所对应的内存集合（和数据结构中的对象含义不同），由头（header）和域（field）组成
  - header负责存储跟具体数据无关的的信息以辅助GC算法实施
  - field负责储存具体的数据，一个对象可以拥有多个field

<img src="https://img-blog.csdnimg.cn/2020090310415033.png#pic_center" style="margin:0"/>

- 根：GC领域的所有镀锡组成了一个树形结构，根表示这棵树的根节点（可以理解为window或者global对象）

---

##### 标记清除算法

标记清除算法分为两个阶段：标记阶段、清除阶段

如一个内存结构：

- c和f被根节点直接引用，于是可以将这两者理解为全局变量
- c引用了a，f引用了e，b引用了d，g没有引用其他对象，也没有被其他对象引用

<img src="https://img-blog.csdnimg.cn/2020090311023588.png" style="margin:0"/>

```
在实际的内存机构中，所有对象在内存中均是相邻的，中间不会有任何空隙
```

**标记阶段**

以根节点作为起点，使用深度优先搜索算法向下遍历所有对象，并在搜索到的所有对象的头部添加标记的引用关系（只有和root产生联系的才会被标记）

```
直接被根节点引用的c和f以及被两者引用的a和c，在标记阶段分别被搜索到并在头部中添加了标记信息
而d虽然被b引用，但是b未关联至根节点，因此bd不会被搜索到
```

<img src="https://img-blog.csdnimg.cn/20200903111454921.png" style="margin:0"/>

**清除阶段**

在标记结果的基础上请删除所有未标记的对象，并且清除已标记对象头部中的标记信息，以便下一次GC流程能正常进行

<img src="https://img-blog.csdnimg.cn/20200903150906492.png" style="margin:0"/>

**合并阶段**

其实标记清除算法的主体在标记阶段和清除阶段已经全部完成，但是具体实施时仍有一些额外的后续补充逻辑

如上图中被清除掉的对象，它们对应的内存空间被存储在非连续的内存空间中，这种状况称为碎片化

碎片化的主要危害：

- 分块的内存的查询效率远低于连续内存
- 造成存储空间的浪费（如新需要一个4MB的内存空间，但是三个碎片的大小均不足4MB，即使三个总大小大于4MB也不能使用，因为是分块的，于是此时只能使用新的空间）

因此通常在清除阶段完成后会额外增加一个合并逻辑，将碎片化的内存重新合并为连续的内存空间（和磁盘整理类似）

<img src="https://img-blog.csdnimg.cn/20200903151837955.png" style="margin:0"/>

```markdown
优点：
	足够简单，可以在此基础上演变出更加完善的GC算法
缺点：
	需要额外补充逻辑以解决内存碎片化的问题
	标记阶段的遍历所消耗的时间跟对象的数量和规模成正比，清除阶段的耗时跟堆的容量也成正比，因此标记清除算法的执行效率随着数据量的增长而下降
	使用标记清除算法的GC操作实际上是一个独立于业务代码逻辑的线程，它类似一个定时器，浏览器每隔一段时间执行一次GC逻辑，会增加浏览器的负荷
```

---

##### 引用计数算法

该算法目前已被淘汰，只为加深标记清除算法了解

每个对象的头部都有一个计数器用于记录引用它的对象个数，每当有新的引用产生时，计数器立即+1，反之-1，当值为0时说明此对象再无引用者，可以安全销毁

<img src="https://img-blog.csdnimg.cn/20200903153648971.png" style="margin:0"/>

对象b和g的计数器均为0，因此两者会被立即回收，由于b被销毁，因此d的计数器变为0也被销毁

乍看之下，引用计数算法不需要遍历整个树形结构，销毁对象也不会受到堆容量的影响，执行效率远胜于标记清除算法，但是有一个致命缺点就是无法处理循环引用

<img src="https://img-blog.csdnimg.cn/20200903154500159.png" style="margin:0"/>

由于b和d互相引用，因此计数器永远不会为0，但是此时b，c没有第三者引用，因此无法访问到它们，浪费了内存

```js
function init() {
    const el = document.getElementById('test')
    el.onclick = function hanlder(event) {
        el.innerText = 'clicked'
    }
}
init = null
```

DOM和handler形成了循环引用的关系，因此即使把init设置为null，也不会将这两者销毁掉，如果业务量多，雪球会越滚越大

因此目前GC算法的最佳选择是标记清除算法，它并没有明显短板，而且在大多数大多数前端数据项目面前，GC效率远没有成为性能瓶颈



---

#### 内存泄漏

在运行应用程序时，计算机管理内存的一般流程是分配→使用→释放，如此循环，内存泄漏指的是一些分配出去的内存空间在使用完后没有被释放

造成内存泄漏的根本原因是不合理的引用

JS引擎的GC操作在语言层面是完全封闭的，因此开发者没有任何直接干预的权限，只能通过编写更合理的代码来避免内存泄漏

**避免全局变量**

减少或避免在全局作用域内创建对象

```js
function foo() {
    bar = 1
}
foo()
foo = null
```

运行函数时，bar会挂载到window对象（相当于root）上，即便之后foo赋值null也不会清除bar占用的内存空间，因为始终被window所引用

**谨慎处理闭包**

```js
function foo() {
    const data = 'data'
    return function() {
        return data
    }
}
const demo = foo()
demo()
```

**定时器使用需要清除**

**手动连接或打开某个应用使用后需要手动关闭**

