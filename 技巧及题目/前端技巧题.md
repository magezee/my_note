## 偏概念

###  map的参数

 **['1', '2', '3'].map(parseInt)运行结果为什么**

**解：[1, NaN, NaN]**

----

**parseInt(string, radix)**

接受两个参数，第二个参数为进制

```jsx
['1', '2', '3'].map((item, index) => {
	return parseInt(item, index)
})
```

```jsx
parseInt('1', 0) // 1
parseInt('2', 1) // NaN，在1进制里没有2
parseInt('3', 2) // NaN，在2进制里没有3
```

----



### 对象的隐式转换

当一个引用类型要去和一个值类型去做比较时，引用类型会尝试将自己转换为值类型，其中涉及到两个方法：

- **Object.valueOf( )**
- **Object.toString( )**

首先会进行调用`value.of`方法，如果返回值仍不为值类型，则会调用`toString`方法

```jsx
const arr = [1,2,3]
const fun = function() { console.log('this is a function') }
const obj = { value: 1 }

// 引用类型使用valueOf()返回的是本身
console.log(arr.valueOf())		// [1,2,3]
console.log(fun.valueOf())		// ƒ () { console.log('this is a function') }
console.log(obj.valueOf())		// { value: 1 }

// 引用类型执行valueOf()后结果
console.log(arr.toString())		// '1,2,3'
console.log(fun.toString())		// 'function() { console.log('this is a function') }'
console.log(obj.toString())		// '[object Object]'

// 验证为string类型
console.log(arr.toString() === '1,2,3')		// true
console.log(fun.toString() === 'function() { console.log(\'this is a function\') }')	// true
console.log(obj.toString() === '[object Object]' )  // true		
```

由原型链的内容可知，自身没有的方法会从原型中继承而来，如果自身拥有则调用自身，上面对象的`value.of`和`toString`都是从`Object`原型中拿来的

**如一个问题：什么情况下`a==1 && a==2 && a==3`**

可以利用隐式转换时自动调用`value.of`和`toString`方法的机制

为一个对象内部自身添加该方法，则隐式调用的时候就可以优先调用对象本身而非原型上的这两个方法，这样就能按照自己的逻辑改写隐式转换的逻辑了

```jsx
let a = { 
	i: 1,
	toString () { 		//或者valueOf 
		return a.i++ 	//根据逻辑，这里是先返return后加 
	} 
} 

if(a == 1 && a == 2 && a == 3) { 
	console.log('成功');		// 成功
}

console.log(a.i)  // 4  每调用一次toString方法i自增，证明确实有在自动调用toString方法
```



---

### this指向

```jsx
// 按顺序写出打印结果
var name = 'global'
var obj = {
    name: 'local',
    foo: function() {
        this.name: 'foo'
    }.bind(window)
}
var bar = new obj.foo()
setTimeout(function() {
    console.log(window.name)
},0)
console.log(bar.name)
var bar3 = bar2 = bar
bar2.name = 'foo2'
console.log(bar3.name)
```

```markdown
# foo，foo2，global

console.log(window.name)在异步里，因此是最后执行

var bar = new obj.foo()
new对的绑定优先级高于bind，因此this不是指向window而是执行bar，因此这里是将bar.name = 'foo'
因此console.log(bar.name)返回'foo'

var bar3 = bar2 = bar
bar2.name = 'foo2'
bar3、bar2、bar只是一个引用，他们最终都指向一个相同的对象，因此通过bar2引用去修改这个对象的属性，其他引用也会受到影响
因此console.log(bar3.name)等同于console.log(bar2.name)返回'foo2'

console.log(window.name),bind并没有成功绑定，window的属性会在全局变量中找，var name = 'global'，因此输出'global'
```

------

### 宏/微异步

```jsx
// 代码运行后结果是什么
setTimeout(() => console.log('a'))
Promise.resolve()
    .then(
        () => console.log('b')
    ).then(
        () => Promise.resolve('c')
            .then(
                (data) => {
                    setTimeout(() => console.log('d'))
                    console.log('f')
                    return data
                }
            )
    ).then(data => console.log(data))
```

```markdown
# 'b' 'f' 'c' 'a' 'd'
setTimeout是异步任务中的宏任务，Promise是异步任务中的微任务，异步微任务会优先执行于宏任务
遇到setTimeout任务先挂起不执行，于是console.log('a')和console.log('d')最后才执行

Promise.resolve('c')
即 data = 'c'
```

```jsx
// 补充:new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
})

console.log(2)
// 1 2 3 4
```



-----

### 原型链

ES6语法糖，ES6和ES5之间的编译过程，JS原型链

```jsx
// 写出ES6编译后所生成ES5的代码
class Person {
    constructor(name) {
        this.name = name
    }
    greet() {
        console.log(`my name is ${this.name}`)
    }
    greetDeley(time) {
        setTimeout(() => {
            console.log(`my name is ${this.name}`)
        },time)
    }
}
```

```jsx
var Person = (function() {
    // 构造函数的实现
    function Person(name) {
        this._name = name
    }
    
    // 向原型中添加类属性，使new的对象能访问
    Person.prototype.greet = function() {
        console.log('my name is ' + this._name)
    }
    Person.prototype.greetDelay = function(time){
        // setTimeout()调用的代码运行在于所在函数完全分离的执行环境上，这回导致这些代码中包含的this会指向window(或全局)对象，因此需要额外this
        var _this = this
        setTimeout(function() {
            console.log('my name is ' + _this.name)
        },time)
    }
})()
```



------

### dom节点查找

```jsx
// 查找两个节点的最近的一个共同父节点，可以包括节点自身，oNode1 和 oNode2 在同一文档中，且不会为相同的节点
function commonParentNode(oNode1, oNode2) {
    while(oNode1){	// oNode1不为空时
        if(oNode1.contains(oNode2)){
            return oNode1
        } 
        else oNode1 = oNode1.parentNode
    }
}

// 思路：寻找A节点的父节点，直到该节点包含B为止，不要同时寻找两个节点的父节点
```



----



## 偏编程

### 实现Promise

```
https://github.com/xieranmaya/blog/issues/3
```



---

### 实现斐波那契

```jsx
var frist = 1
var second = 1
var sum = 0
function list (N) {
    for(var i=0; i < N; i++){
        sum = frist + second
        frist = second
        second = sum
    }
    return sum
}
```

使用递归方式

```jsx
function list (N) {   
        if(N < 3 )
        {
            return 1
        }
        else return list(N-1) + list(N-2)
}
```

尾递归

```jsx
function list(N, ret1, ret2){
    if(n ==0)
        return ret1
    else
        return list(n-1, ret2, ret1 + ret2)
}
```

---

### 闭符处理

**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效**

```markdown
有效字符串需满足：
    左括号必须用相同类型的右括号闭合
    左括号必须以正确的顺序闭合
    注意空字符串可被认为是有效字符串
```

如：

````
输入: "()[]{}"
输出: true

输入: "{[]}"
输出: true

输入: "([)]"
输出: false
````

实现思路：

括号嵌套的规则，最里层出现的一个左符号，下一次出现的右符号必定和左符号对应

因此使用栈的特性

```js
var isValid = function(s) {
    // 这个对象的设计是精华所在，注意是右括为属性名
    var Json = {
              ')': '(',
              ']': '[',
              '}': '{'
        }
        var stack = [];
        for (var i = 0; i < s.length; i++) {
            var c = s[i];
            if (c in Json) {
                var template = stack.length === 0 ? '#' : stack.pop() ;   // 任意给定的一个字符，当栈中没有压入左符号而出现对应右符号时，说明不符合返回false
                if (template !== Json[c]) {
                    return false;
            }
  
            } else {
                stack.push(c);
            }
        }

        return stack.length == 0;
    };

console.log(isValid('{{[]{}}}'))	// true
```

<img src="https://img-blog.csdnimg.cn/20200525142432367.png" style="float:left;">



---

### 数组

#### 扁平化

```
https://juejin.im/post/6875152247714480136
```



#### 数组去重



---

### 延时链式调用

要求对象实例可以实现延时链式调用

```js
function LazyMan(name) {
    this.name = name
    this.time = 0
    console.log(name)

    this.sleep = function(time) {
        this.time = time
        new Promise((resolve) => {
            setTimeout(() => {
                console.log(time)
                this.time = 0
                resolve()
            },time)
        })
        return this
    }

    this.eat = function(food) {
        setTimeout(() => {
            console.log(food)
        }, this.time);
        return this
    }
}

const lazyMan = new LazyMan('Hank')
lazyMan.sleep(1000).eat('breakfast').sleep(5000).eat('lunch')

// Hank 1000 breakfast 5000 lunch
```



---

### 数组顺序拼接

```js
// arr1,arr2已排序，从小到大
// 利用已经排序好的数组将两个数组合并为一个并按循序排列好
var arr1 = [1,2,5,6]
var arr2 = [3,4,7,8]
function mergearay(arr1, arr2) {
    let i = 0
    let j = 0
    let arr = []
  
    while(i < arr1.length || j < arr2.length) {
        // 两个数组都没遍历完的情况，由于是已经排序好的数组，因此可以确保后加入的一定比之前的大，可以放心push
        if(i < arr1.length && j < arr2.length) {  
            if(arr1[i] < arr2[j]) {
                arr.push(arr1[i])
                i += 1
            } else {
                arr.push(arr2[j])
                j += 1
            } 
        }
        
        // 遍历完arr2的情况，说明剩下的arr1全都比arr2大，可以直接加入
        else if (i < arr1.length) {
            arr.push(arr1[i])
            i +=1
        } 

        // 遍历完arr1的情况，同理
        else {
            arr.push(arr2[j])
            j += 1
        }
    }
    return arr
}

console.log(mergearay(arr1,arr2))
```



---

### 按条件分割数组

写一个chunk函数，按照指定参数进行数组拆分，长度不够的放在最后

```js
function chunk(arr, size) {
    let result = []
    let source = [...arr]
    while(source.length) {
        result.push([...source.splice(0, size)])
    }
    return result
}

chunk(["a", "b", "c", "d"], 2)  //  [['a', 'b'], ['c', 'd']]
chunk(["a", "b", "c", "d"], 3)  //  [['a', 'b', 'c'], ['d']]
```

