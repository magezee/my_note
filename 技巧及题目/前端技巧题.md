## function sum(...args) {

  const f = (...rest) => {

​    sum(...args, ...rest)  // 闭包确保能拿到之前传入的所有形参

  }

  f.valueof = () => {

​    args.reduce.reduce((x, y) => {

​      x + y

​    },0)

  }

}偏概念

###  map的参数

 **['1', '2', '3'].map(parseInt)运行结果为什么**

**解：[1, NaN, NaN]**

----

**parseInt(string, radix)**

接受两个参数，第二个参数为进制

```jsx
['1', '2', '3'].map((item, index) => {
	return parseInt(item, index)
})
```

```jsx
parseInt('1', 0) // 1
parseInt('2', 1) // NaN，在1进制里没有2
parseInt('3', 2) // NaN，在2进制里没有3
```

----



### 对象的隐式转换

当一个引用类型要去和一个值类型去做比较时，引用类型会尝试将自己转换为值类型，其中涉及到两个方法：

- **Object.valueOf( )**
- **Object.toString( )**

首先会进行调用`value.of`方法，如果返回值仍不为值类型，则会调用`toString`方法

```jsx
const arr = [1,2,3]
const fun = function() { console.log('this is a function') }
const obj = { value: 1 }

// 引用类型使用valueOf()返回的是本身
console.log(arr.valueOf())		// [1,2,3]
console.log(fun.valueOf())		// ƒ () { console.log('this is a function') }
console.log(obj.valueOf())		// { value: 1 }

// 引用类型执行valueOf()后结果
console.log(arr.toString())		// '1,2,3'
console.log(fun.toString())		// 'function() { console.log('this is a function') }'
console.log(obj.toString())		// '[object Object]'

// 验证为string类型
console.log(arr.toString() === '1,2,3')		// true
console.log(fun.toString() === 'function() { console.log(\'this is a function\') }')	// true
console.log(obj.toString() === '[object Object]' )  // true		
```

由原型链的内容可知，自身没有的方法会从原型中继承而来，如果自身拥有则调用自身，上面对象的`value.of`和`toString`都是从`Object`原型中拿来的

**如一个问题：什么情况下`a==1 && a==2 && a==3`**

可以利用隐式转换时自动调用`value.of`和`toString`方法的机制

为一个对象内部自身添加该方法，则隐式调用的时候就可以优先调用对象本身而非原型上的这两个方法，这样就能按照自己的逻辑改写隐式转换的逻辑了

```jsx
let a = { 
	i: 1,
	toString () { 		//或者valueOf 
		return a.i++ 	//根据逻辑，这里是先返return后加 
	} 
} 

if(a == 1 && a == 2 && a == 3) { 
	console.log('成功');		// 成功
}

console.log(a.i)  // 4  每调用一次toString方法i自增，证明确实有在自动调用toString方法
```



---

### this指向

```jsx
// 按顺序写出打印结果
var name = 'global'
var obj = {
    name: 'local',
    foo: function() {
        this.name: 'foo'
    }.bind(window)
}
var bar = new obj.foo()
setTimeout(function() {
    console.log(window.name)
},0)
console.log(bar.name)
var bar3 = bar2 = bar
bar2.name = 'foo2'
console.log(bar3.name)
```

```markdown
# foo，foo2，global

console.log(window.name)在异步里，因此是最后执行

var bar = new obj.foo()
new对的绑定优先级高于bind，因此this不是指向window而是执行bar，因此这里是将bar.name = 'foo'
因此console.log(bar.name)返回'foo'

var bar3 = bar2 = bar
bar2.name = 'foo2'
bar3、bar2、bar只是一个引用，他们最终都指向一个相同的对象，因此通过bar2引用去修改这个对象的属性，其他引用也会受到影响
因此console.log(bar3.name)等同于console.log(bar2.name)返回'foo2'

console.log(window.name),bind并没有成功绑定，window的属性会在全局变量中找，var name = 'global'，因此输出'global'
```

------

### 宏/微异步

```jsx
// 代码运行后结果是什么
setTimeout(() => console.log('a'))
Promise.resolve()
    .then(
        () => console.log('b')
    ).then(
        () => Promise.resolve('c')
            .then(
                (data) => {
                    setTimeout(() => console.log('d'))
                    console.log('f')
                    return data
                }
            )
    ).then(data => console.log(data))
```

```markdown
# 'b' 'f' 'c' 'a' 'd'
setTimeout是异步任务中的宏任务，Promise是异步任务中的微任务，异步微任务会优先执行于宏任务
遇到setTimeout任务先挂起不执行，于是console.log('a')和console.log('d')最后才执行

Promise.resolve('c')
即 data = 'c'
```

```jsx
// 补充:new Promise在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
})

console.log(2)
// 1 2 3 4
```



-----

### 原型链

ES6语法糖，ES6和ES5之间的编译过程，JS原型链

```jsx
// 写出ES6编译后所生成ES5的代码
class Person {
    constructor(name) {
        this.name = name
    }
    greet() {
        console.log(`my name is ${this.name}`)
    }
    greetDeley(time) {
        setTimeout(() => {
            console.log(`my name is ${this.name}`)
        },time)
    }
}
```

```jsx
var Person = (function() {
    // 构造函数的实现
    function Person(name) {
        this._name = name
    }
    
    // 向原型中添加类属性，使new的对象能访问
    Person.prototype.greet = function() {
        console.log('my name is ' + this._name)
    }
    Person.prototype.greetDelay = function(time){
        // setTimeout()调用的代码运行在于所在函数完全分离的执行环境上，这回导致这些代码中包含的this会指向window(或全局)对象，因此需要额外this
        var _this = this
        setTimeout(function() {
            console.log('my name is ' + _this.name)
        },time)
    }
})()
```



------

### dom节点查找

```jsx
// 查找两个节点的最近的一个共同父节点，可以包括节点自身，oNode1 和 oNode2 在同一文档中，且不会为相同的节点
function commonParentNode(oNode1, oNode2) {
    while(oNode1){	// oNode1不为空时
        if(oNode1.contains(oNode2)){
            return oNode1
        } 
        else oNode1 = oNode1.parentNode
    }
}

// 思路：寻找A节点的父节点，直到该节点包含B为止，不要同时寻找两个节点的父节点
```



----



## 偏编程

### 实现Promise

```
具体的：https://github.com/xieranmaya/blog/issues/3
比较简单的：https://q.shanyue.tech/fe/js/23.html
```

**Promise标准：**

- 拥有`then` 方法，该方法返回一个全新的 Promise 对象，而不是返回当前实例 this

```js
let pro1 = new Promise(()=>{})
let pro2 = pro1.then()
console.log(pro1 != pro2)      // true
```

```js
promise2 = promise1.then(function foo(value) {
  return Promise.reject(3)
})
// 此处如果foo运行了，则promise1的状态必然已经确定且为resolved，如果then返回了this（即promise2 === promise1），说明promise2和promise1是同一个对象，而此时promise1/2的状态已经确定，没有办法再取Promise.reject(3)的状态和结果为己用，因为Promise的状态确定后就不可再转换为其它状态。
// 另外每个Promise对象都可以在其上多次调用then方法，而每次调用then返回的Promise的状态取决于那一次调用then时传入参数的返回值，所以then不能返回this，因为then每次返回的Promise的结果都有可能不同
```

- 不同的 Promise 实例可以相互调用，因此看起来像是在自身一直在链式调用，实际上是不同的实例在互相调用

- Promise的初始状态为 `pending` ，它可以由此状态转为 `resolved` 或者 `rejected`，一旦状态确定，就不可用再次转为其他状态

**构造函数**

Promise 构造函数接受一个方法，该方法执行完同步或异步操作后，调用它的两个参数 resolve 和 reject（这里这两个参数尚未定义）

由于 Promise 的特点是，上一个 Promise 状态为非 pending 才会执行下一个，因此设置一个回调函数队列，如果当前 Promise 的状态为 pengding，则将后面的回调函数都存放在 reject 和 reject 队列中，如果当前 Promise 执行后状态为 reject 则执行 reject 队列的全部函数，否则则执行 reject 队列的

```js
class FakePromise {
    constructor(fn) {
        this.status = 'PENDING'     // Promise当前状态，不更改的字符一般用大写字母
        this.data = undefined       // Promise的值
        this.resolveFns = []        // Promise resolve时的回调函数队列
        this.rejectFns = []         // Promise reject时的回调函数队列

        fn(resolve, reject)         // 并将resolve和reject传进去并执行fn
    }
}
```

**定义 resolve 和 reject 方法**

考虑到 this 指向问题，将这两个方法也写进构造函数中

```js
// 将pending改为resolve，把value存进自身data值，并且传入value依次调用函数队列中的所有方法
const resolve = (value) => {
    if(this.status === 'PENDING') {
        this.status = 'RESOLVED'
        this.data = value
        this.resolveFns.forEach(resolveFn => {
            resolveFn(value)
        })
    }
}
// 同理
const reject = (reason) => {
    if(this.status === 'PENDING') {
        this.status = 'REJECTED'
        this.data = reason
        this.rejectFns.forEach(rejectFn => {
            rejectFn(reason)
        })
    }
}
```

**then**

Promise 对象的then方法用来注册该 Promise 状态确定后的回调，then 方法需要写在原型链上面，该方法会返回一个新的 Promise 对象

then 方法接受两个参数 —— `onResolved`，`onRejected`，分别为Promise成功或失败后的回调，如果传入 then 的参数不是一个 function，则忽略

```js
then(onResolved, onRejected) {
    onResolved = typeof onResolved === 'function' ? onResolved : function(v) {}
    onRejected = typeof onRejected === 'function' ? onRejected : function(r) {}

    if(this.status === 'RESOLVED') {
        return new Promise((resolve, reject) => {

        })
    }
    if(this.status === 'REJECTED') {
        return new Promise((resolve, reject) => {

        })
    }
    if(this.status === 'PENDING') {
        return new Promise((resolve, reject) => {

        })
    }
}
```

返回新的 Promise 的值取决于 then 中函数的返回值

```js
// 如果promise1被resolve了，promise2的将被4,状态置为resolve
// 如果promise1被reject了，promise2将被new Error('sth went wrong')，状态置为reject
promise2 = promise1.then((value) => {
  return 4
}, reason => {
  throw new Error('sth went wrong')
})
```

所以需要在then里面执行 `onResolved` 或 `onRejected`，并根据返回值(标准中记为x)来确定新的 Promise 结果，并且，如果 `onResolved` 或 `onRejected` 返回的是一个Promise，新的 Promise 将该Promise的结果

```js
then(onResolved, onRejected) {
    onResolved = typeof onResolved === 'function' ? onResolved : function(v) {}
    onRejected = typeof onRejected === 'function' ? onRejected : function(r) {}

    if(this.status === 'RESOLVED') {
        return new Promise((resolve, reject) => {
            try {
                let x = onResolved(this.data)   // 相当于Promise.resolve(4).then((value)=>{}) data=4,将当前promise的value传递给下一个
                if(x instanceof FakePromise) {  // 如果onResolved的返回值是一个Promise对象，则直接取该Promise作为新的Promise
                    x.then(resolve, reject)     
                }
                resolve(x)                      // 如果不是一个Promise，则以它的返回值作为新的Promise结果
            } catch(e) {
                reject(e)                       // 如果报错，则将捕获到的错误作为新的Promise结果
            }
        })
    }

    if(this.status === 'REJECTED') {
        return new Promise((resolve, reject) => {
            try {
                let x = onRejected(this.data)  
                if(x instanceof FakePromise) { 
                    x.then(resolve, reject)     
                }
                resolve(x)                     
            } catch(e) {
                reject(e)                       
            }
        })
    }

    // 如果当前的Promise还处于pending状态，则无法确定调用onResolved还是onRejected，于是只能等待该Promise状态确定才能往下进行，等于Promise的阻塞执行
    // 由于不知道具体状态，因此后续调用的回调函数在resolveFns和rejectFns都应该存在，如果该Promise为reject则继续调用resolveFns内所有函数，否则调用rejectFns的
    // 相当于把上面的两个方法先存起来，不立即调用，之后再调用
    if(this.status === 'PENDING') {
        return new Promise((resolve, reject) => {
            this.resolveFns.push((value) => {
                try {
                    let x = onResolved(this.data)   
                    if(x instanceof FakePromise) {  
                        x.then(resolve, reject)     
                    }
                    resolve(x)                      
                } catch(e) {
                    reject(e)                       
                }
            })

            this.rejectFns.push((reason) => {
                try {
                    let x = onResolved(this.data)   
                    if(x instanceof FakePromise) {  
                        x.then(resolve, reject)     
                    }
                    resolve(x)                      
                } catch(e) {
                    reject(e)                       
                }
            })
        })
    }
}
```

**catch**

```js
catch(onRejected) {
    return this.then(null, onRejected)
}
```

**全部代码如下**

```js
class FakePromise {
    constructor(fn) {
        this.status = 'PENDING'     // Promise当前状态，不更改的字符一般用大写字母
        this.data = undefined       // Promise的值
        this.resolveFns = []        // Promise resolve时的回调函数队列
        this.rejectFns = []         // Promise reject时的回调函数队列

        fn(resolve, reject)         // 并将resolve和reject传进去并执行fn

        // 将pending改为resolve，把value存进自身data值，并且传入value依次调用函数队列中的所有方法
        const resolve = (value) => {
            if(this.status === 'PENDING') {
                this.status = 'RESOLVED'
                this.data = value
                this.resolveFns.forEach(resolveFn => {
                    resolveFn(value)
                })
            }
        }
        // 同理
        const reject = (reason) => {
            if(this.status === 'PENDING') {
                this.status = 'REJECTED'
                this.data = reason
                this.rejectFns.forEach(rejectFn => {
                    rejectFn(reason)
                })
            }
        }
    }

    then(onResolved, onRejected) {
        onResolved = typeof onResolved === 'function' ? onResolved : function(v) {}
        onRejected = typeof onRejected === 'function' ? onRejected : function(r) {}

        if(this.status === 'RESOLVED') {
            return new Promise((resolve, reject) => {
                try {
                    let x = onResolved(this.data)   // 相当于Promise.resolve(4).then((value)=>{}) data=4,将当前promise的value传递给下一个
                    if(x instanceof FakePromise) {  // 如果onResolved的返回值是一个Promise对象，则直接取该Promise作为新的Promise
                        x.then(resolve, reject)     
                    }
                    resolve(x)                      // 如果不是一个Promise，则以它的返回值作为新的Promise结果
                } catch(e) {
                    reject(e)                       // 如果报错，则将捕获到的错误作为新的Promise结果
                }
            })
        }

        if(this.status === 'REJECTED') {
            return new Promise((resolve, reject) => {
                try {
                    let x = onRejected(this.data)  
                    if(x instanceof FakePromise) { 
                        x.then(resolve, reject)     
                    }
                    resolve(x)                     
                } catch(e) {
                    reject(e)                       
                }
            })
        }

        // 如果当前的Promise还处于pending状态，则无法确定调用onResolved还是onRejected，于是只能等待该Promise状态确定才能往下进行，等于Promise的阻塞执行
        // 由于不知道具体状态，因此后续调用的回调函数在resolveFns和rejectFns都应该存在，如果该Promise为reject则继续调用resolveFns内所有函数，否则调用rejectFns的
        // 相当于把上面的两个方法先存起来，不立即调用，之后再调用
        if(this.status === 'PENDING') {
            return new Promise((resolve, reject) => {
                this.resolveFns.push((value) => {
                    try {
                        let x = onResolved(this.data)   
                        if(x instanceof FakePromise) {  
                            x.then(resolve, reject)     
                        }
                        resolve(x)                      
                    } catch(e) {
                        reject(e)                       
                    }
                })

                this.rejectFns.push((reason) => {
                    try {
                        let x = onResolved(this.data)   
                        if(x instanceof FakePromise) {  
                            x.then(resolve, reject)     
                        }
                        resolve(x)                      
                    } catch(e) {
                        reject(e)                       
                    }
                })
            })
        }
    }

    catch(onRejected) {
        return this.then(null, onRejected)
    }
    
}
```

测试代码，目前这个 Promise 的功能尚未齐全需要改进，但是面试写到这步已经接近满分

```js
const pro = new FakePromise((resolve, reject) => {
    resolve(1)
})
pro.then(data => {
    setTimeout(()=> {
        console.log(data)   // 1，后打印
    })
    return 2
}).then(data => {
    console.log(data)       // 2,先打印
})
```



----

### 实现bind

利用 apply 方法，因为 rest 参数会存为一个数组，和 apply 参数相符

```js
Function.prototype.fakeBind = function(obj) {
    return (...args) => this.apply(obj,args)

let a = 1

function f (...arg) {
  console.log(this.a)
  console.log(arg)
}
f(1)                            // 1 [1]
f.bind({ a: 3 })(4,5,6)         // 3 [4,5,6]
f.fakeBind({ a: 3 })(4)         // 3 [4]
```



---

### 实现斐波那契

斐波那契：`1,1,3,4,7……`

```jsx
var frist = 1
var second = 1
var sum = 0
function list (N) {
    for(var i=0; i < N; i++){
        sum = frist + second
        frist = second
        second = sum
    }
    return sum
}
```

使用递归方式

```jsx
function list (N) {   
        if(N < 3 )
        {
            return 1
        }
        else return list(N-1) + list(N-2)
}
```

尾递归

```jsx
function list(N, ret1, ret2){
    if(n ==0)
        return ret1
    else
        return list(n-1, ret2, ret1 + ret2)
}
```

---

### 闭符处理

**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效**

```markdown
有效字符串需满足：
    左括号必须用相同类型的右括号闭合
    左括号必须以正确的顺序闭合
    注意空字符串可被认为是有效字符串
```

如：

````
输入: "()[]{}"
输出: true

输入: "{[]}"
输出: true

输入: "([)]"
输出: false
````

实现思路：

括号嵌套的规则，最里层出现的一个左符号，下一次出现的右符号必定和左符号对应

因此使用栈的特性

```js
var isValid = function(s) {
    // 这个对象的设计是精华所在，注意是右括为属性名
    var Json = {
              ')': '(',
              ']': '[',
              '}': '{'
        }
        var stack = [];
        for (var i = 0; i < s.length; i++) {
            var c = s[i];
            if (c in Json) {
                var template = stack.length === 0 ? '#' : stack.pop() ;   // 任意给定的一个字符，当栈中没有压入左符号而出现对应右符号时，说明不符合返回false
                if (template !== Json[c]) {
                    return false;
            }
  
            } else {
                stack.push(c);
            }
        }

        return stack.length == 0;
    };

console.log(isValid('{{[]{}}}'))	// true
```

<img src="https://img-blog.csdnimg.cn/20200525142432367.png" style="float:left;">



---

### 数组

#### 扁平化

```
https://juejin.im/post/6875152247714480136
```



#### 数组去重



---

### sleep链式调用

**sleep函数**

使用 Promise 的写法是方便在 Promise 函数中调用

```js
function sleep(time) {
    return new Promise((resolve)=> {
        setTimeout(() => {
            resolve()
        }, time)
    })
}
```

要求对象实例可以实现延时链式调用

```js
function LazyMan(name) {
    this.name = name
    this.time = 0
    console.log(name)

    this.sleep = function(time) {
        this.time = time
        setTimeout(() => {
            console.log(time)
            this.time = 0
        },time)
        return this
    }

    this.eat = function(food) {
        setTimeout(() => {
            console.log(food)
        }, this.time);
        return this
    }
}

const lazyMan = new LazyMan('Hank')
lazyMan.sleep(1000).eat('breakfast').sleep(5000).eat('lunch')

// Hank 1000 breakfast 5000 lunch
```



---

### 数组顺序拼接

```js
// arr1,arr2已排序，从小到大
// 利用已经排序好的数组将两个数组合并为一个并按循序排列好
var arr1 = [1,2,5,6]
var arr2 = [3,4,7,8]
function mergearay(arr1, arr2) {
    let i = 0
    let j = 0
    let arr = []
  
    while(i < arr1.length || j < arr2.length) {
        // 两个数组都没遍历完的情况，由于是已经排序好的数组，因此可以确保后加入的一定比之前的大，可以放心push
        if(i < arr1.length && j < arr2.length) {  
            if(arr1[i] < arr2[j]) {
                arr.push(arr1[i])
                i += 1
            } else {
                arr.push(arr2[j])
                j += 1
            } 
        }
        
        // 遍历完arr2的情况，说明剩下的arr1全都比arr2大，可以直接加入
        else if (i < arr1.length) {
            arr.push(arr1[i])
            i +=1
        } 

        // 遍历完arr1的情况，同理
        else {
            arr.push(arr2[j])
            j += 1
        }
    }
    return arr
}

console.log(mergearay(arr1,arr2))
```



---

### 按条件分割数组

写一个chunk函数，按照指定参数进行数组拆分，长度不够的放在最后

```js
function chunk(arr, size) {
    let result = []
    let source = [...arr]
    while(source.length) {
        result.push([...source.splice(0, size)])
    }
    return result
}

chunk(["a", "b", "c", "d"], 2)  //  [['a', 'b'], ['c', 'd']]
chunk(["a", "b", "c", "d"], 3)  //  [['a', 'b', 'c'], ['d']]
```



----

### 实现判断纯对象

纯对象实际上就是没有 Object 原型链

```js
function _isPlainObject(obj) {
    if(typeof obj !== 'object' || obj === null) return false
    if(Object.getPrototypeOf(obj)) return false
    else return true
}

let a = {}
let b = Object.create(null)
console.log(_isPlainObject(a))      // false
console.log(_isPlainObject(b))      // true
```



---

### 懒计算函数

可以无限往里面传参，拥有一个方法可以调用显示当前结果

- sum 返回一个函数，收集所有的累加项，使用递归实现

- 返回函数带有 `valueOf` 属性，用于统一计算

```js
function sum(...args) {
    const f = (...rest) => {
        sum(...args, ...rest)   // 闭包确保能拿到之前传入的所有形参
    }
    
    f.valueof = () => {
        args.reduce.reduce((x, y) => {
            x + y
        },0)
    }
    
    ret
}
```

```js
sum(1, 2, 3).valueOf() //6
sum(2, 3)(2).valueOf() //7
sum(1)(2)(3)(4).valueOf() //10
sum(2)(4, 1)(2).valueOf() //9
sum(1)(2)(3)(4)(5)(6).valueOf() // 21
```

