### diff算法

**dom节点**

```jsx
<ul>
	<li></li>	
    <li>
    	<p></p>
        <div></div>
    </li>
	<li></li>
</ul>
```

<img src="https://upload-images.jianshu.io/upload_images/7243642-45739cc8c4a5b906.png" style="float:left;width:300px;heigh:300px">

#### tree diff

React的做法是把dom tree分层级

对于两个dom tree只比较同一层次的节点，忽略Dom中节点跨层级移动操作，只对同一个父节点下的所有的子节点进行比较，如果对比发现该父节点不存在则直接删除该节点下所有子节点，不会做进一步比较。

对于跨层级的dom，如图：两个tree进行对比，右边的新tree发现A节点已经没有了，则会直接销毁A以及下面的子节点B、C；在D节点上面发现多了一个A节点，则会重新创建一个新的A节点以及相应的子节点

<img src="https://img-blog.csdn.net/20180403132519897" style="float left">

具体的操作顺序：create A → create B → creact C → delete A

**tree diff优化：保证稳定dom结构有利于提升性能，不建议频繁真正的移除或者添加节点**

----

#### component diff

React应用是基于组件构建的，对于组件的比较优化侧重于以下几点：

- 同一类型组件遵从tree diff比较v-dom树
- 不通类型组件，先将该组件归类为dirty component，替换下整个组件下的所有子节点
- 同一类型组件Virtual Dom没有变化，React允许开发者使用shouldComponentUpdate（）来判断该组件是否进行diff，运用得当可以节省diff计算时间，提升性能

<img src="https://img-blog.csdn.net/2018040313254025" style="float left">

如图：当组件D → 组件G时，diff判断为不同类型的组件，虽然它们的结构相似甚至一样，diff仍然不会比较二者结构，会直接销毁D及其子节点，然后新建一个G相关的子tree，这显然会影响性能，官方虽然认定这种情况极少出现，但是开发中的这种现象造成的影响是非常大的

**component diff优化：对于同一类型组件合理使用shouldComponentUpdate（），应该避免结构相同类型不同的组件**

-----

#### element diff

对于同一层级的element节点，diff提供了以下3种节点操作：

- 插入：
- 移动：
- 移除

一般diff在比较集合[A,B,C,D]和[B，A，D，C]的时候会进行全部对比，即按对应位置逐个比较，发现每个位置对应的元素都有所更新，则把旧集合全部移除，替换成新的集合，这是复杂、低效、影响性能的操作，因为新集合中所有的元素都可以进行复用，无需删除重新创建，耗费性能和内存，只需要移动元素位置即可

<img src="https://img-blog.csdn.net/20180403132558624" style="float left">

-----

#### Key配合diff算法

React允许开发者对同一层级的同组子节点添加唯一key值进行区分

**react diff思路：**

- **遍历一遍新集合和一遍旧集合，然后开始对比**
- **从下标0开始遍历新数组，此下标节点的的key在旧数组中也有：**
  - **如果同key节点在新节点的下标比旧节点的大（靠右），则记录该下标，更新时将旧节点移动到此**
  - **若同key节点在新节点下标较小，则不移动，进行下一个下标节点比较**
- **若此下标位置的新节点在旧节点中找不到，则记录此该下标，更新时将新节点插入到此**
- **遍历完成后，判断旧节点是否含有新节点中找不到的key，如果有，更新时将旧节点删除**

----

**移动**：

React会先进行新集合遍历，for(name in nextChildren)，通过key值判断两个对比集合中是否存在相同的节点，即if(prevChild === nextChild)，如何为true则进行移动操作

在此之前，需要执行被移动节点在新旧（child._mountIndex）集合中的位置比较，if(child._mountIndex < lastIndex)为true时进行移动，否则不执行该操作，这实际上是一种顺序优化，lastIndex是不断更新的，表示访问过的节点在集合中的最右的位置。若当前访问节点在旧集合中的位置比lastIndex大，即靠右，说明它不会影响其他元素的位置，因此不用添加到差异队列中，不执行移动操作，反之则进行移动操作

<img src="https://img-blog.csdn.net/20180403132613734" style="float left">





- `nextIndex = 0`，`lastIndex = 0`，从新集合中获取B，在旧集合中发现相同节点B

- 旧集合中：`B._mountIndex = 1`，`child._mountIndex < lastIndex ==> false`，不执行移动操作

- 在新集合中：`B._mountIndex = 0`，`nextIndex++`，进行下一个节点判断

  -----

- `nextIndex = 1`，`lastIndex = 1`，从新集合中获取A，在旧集合中发现相同节点A

- 旧集合中：`A._mountIndex = 0`，`child._mountIndex < lastIndex ==> true`，对A进行移动操作

- 更新A在新集合中的位置`prevChild._mountIndex = nextIndex`

- 在新集合中：A._mountIndex = 1，nextIndex++，进行下一个节点判断

----

**增删：**

<img src="https://img-blog.csdn.net/20180403132628782" style="float left">

----

**优化后diff的不足**

<img src="https://img-blog.csdn.net/20180403132642769" style="float left">

由前面思路可知，当一个最末的节点D移动到最前时，不是D直接移动到最前，而是A、B、C节点相应地移动到了1,2,3位置，于是D自动成了第0位

**React优化建议：**

- **在开发过程中，同层级的节点添加唯一key值可以极大提升性能**
- **尽量减少将最后一个节点移动到列表首部的操作**
- **当节点达到一定的数量以后或者操作过于频繁，在一定程度上会影响React的渲染性能，比如大量节点拖拽排序的问题**



```
写 React / Vue 项目时为什么要在列表组件中写 key，其作用是在diff算法执行时更快的找到对应的节点，提高diff速度
如果不是map这种遍历生成的节点，手动编写节点时会自动带上一个看不见的唯一key作用和这个一样
```



----

**不用数组下标当key的原因**

如删除其中一个节点，本来 `A B C D` 对应的数组下标为 `[0,1,2,3]`，删除 B 后，会带来新的数组下标变化 `[0,1,2]`，此时A对应0，C对应1，D对应2，很明显 key 值发生了变化，如果使用 diff 进行搜索，前后 dom 的 key 几乎变动了，于是 diff 会认为 大量的 dom 发生了变化

