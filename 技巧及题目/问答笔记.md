## 问答笔记

### 介绍



### ES6新特性

​		我先说一下我实际用的比较多的吧

​		首先ES6的模块化有了新的分化，以前使用的 JS 模块称为 **CommonJS 模块**，主要使用 **require**导入， 现在新增了一个 **ES6模块**，使用的是 **import** 方式导入，然后我说说 require 和 import 的主要区别把，首先**require 同步加载**，**而 import 是异步加载**，就是 require 会在引入时执行模块文件代码，而 import 只有在用到该模块部分时才会执行，**require 在运行时加载**，**而 import 在编译时加载**，然后 require 只能**引入全部**的代码文件，而 import 可以**按需引入**，只引入一部分代码，还有一个比较重要的是 require 引用是**值的拷贝**，相当于把模块代码拷贝了一份到当前文件中，所以在当前文件对模块代码进行操作时不会影响到模块文件，而 import 相当于是**值的引用**，对模块代码进行操作会直接影响到模块文件代码，模块化的内容大概是那么多

​		然后 ES6 增加了一个作用域，**块级作用域**，以前的 JS 有三种作用域，一个是全局作用域，浏览器环境的话是 `window`，Node 环境的是 `global`，还有一个函数作用域，就是函数内部的，最后一个是动态作用域 this，它只有在执行时才会确定具体的作用域，ES6 增加了块级作用域，用大括号表示范围，主要体现在条件语句和循环语句中，同时为了和块级作用域搭配新增了两种声明变量的方式，**let** 和 **const** ，它们和 var 的一个主要区别是**不存在变量提升**，同一作用域下**不可以多次声明同名变量**

​		还有 ES6 新增了 **class**，相当于用原型链声明构造函数和实现继承的**语法糖**，**从构造函数功能来说**的话，以前的一些公共的方法或者属性得放在原型链的原型上，然后构造函数new的实例就可以顺着原型链拿到这些方法和属性，但是这样做也不保险，因为实例可以直接修改原型链上的引用类型数据，所以一般是在构造函数中将需要公开的方法和属性用this表示，这样 new 的时候 this 指向实例，就会在实例中创建这些方法和属性，这样改写的时候是优先改写自身的，就保障了原型链的安全，然后如果使用 class 的话就没有那么麻烦，直接在类中正常声明就好了，会自动隐性地添加到原型中，**从继承功能上来说**，以前实现继承的主要是用父类的实例对象来当成子类的原型，然后再在子类里调用一次父类构造函数并把 this 指向自己，而使用类则只需要简单的 extent 就能做到这些功能

​		ES6 比较常用的还有**箭头函数**，它和普通函数不同的是首先它并不是用函数式声明的，所以**不存在函数提升**，然后箭头函数最主要的特点是它**不产生this**，它的 this由最近父级函数产生，因此 **和最近父级函数 this 的指向完全一致**，而且不能通过更改 this 的函数如 call，apply，bind 来更改其指向，因为没有 this 所以不能作为构造函数，将 this 指向实例从而 new 一个实例出来，所以箭头函数是**没有原型链**的说法的，自然也**没有原型属性**，然后箭头函数也**没有 argument 对象**，因此如果获取剩余的传入形参则**使用 rest 参数**，最后箭头函数不能当做 Generator 函数来使用

​		