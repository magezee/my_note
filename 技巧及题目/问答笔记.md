## 问答笔记

### 介绍

​		我本科在上海师范大学读，专业是电子信息工程，是一个软硬件都会接触的专业，大学学过的编程语言是 C 和 C#，接触面向对象的内容就是学 C# 的时候学的，去年毕业出来通过校招的方式进了交通银行信用卡中心的性能测试，我本来是想找开发的工作的，但是当时拿到的 offer 都不是很满意，现在这份工作是我拿到最好的 offer，而且当时那边的高管和我说性能测试和功能测试不一样，能接触到很多需要技术的东西，然后我觉得也还行，就进去了，不过干了两个月之后感觉还是开发有意思，毕竟测别人的代码性能没有自己写代码那种生产的成就感，于是我现在就决定转行

​		我说说我学前端的经历吧，选择前端是因为当时我有不少同学在干这行，然后他们推荐我试试，然后我就去用了一下，发现代码可以即使反馈视觉效果感觉还蛮好玩的，于是就一直学下去了，大概是去年八月份开始学吧

​		然后就是我学过的内容，最开始学的就是 JS、HTML、CSS 这些，现在在用的语言是 TS，后端内容的学了 NodeJS，不过现在好像都是用它当中端处理，当时用 express 框架搭后端服务，然后搞了一个简易的博客网页，主要用的是 ejs 渲染，然后后面接触到了现在比较流行的 koa 框架，就尝试着配合 Ts 和 MongoDB 把之前的项目重构了一下，就是我简历里的第一个项目

​		后端差不多是这些内容，然后前端的话，当时在考虑 React 和 Vue 学哪个，然后我看 react 用的人比较多就去学了 react，常见的配合 react 的东西我都差不多用过，比如 路由管理react-router，前后端交互 axios，状态管理 redux，然后 redux 用过的中间件有 thunk 和 saga，之前也尝试着开发了一个前后端分离的 react 项目，前端主要使用的技术栈是 react，react-router，redux，redux-saga，还用到了一些 antd 组件，然后后端主要使用的是 koa 和 MongoDB，就是我简历中的第二个项目，最后还有一些 Webpack 的使用和功能配置也了解过

​		然后再说说现在计划做的事情吧，一个是想把微信生态的内容学习一下，目前正在学小程序，想着学的差不多之后去研究公众号，还有一个是现在正在搞的项目是仿着明日方舟的官方搭一遍，这两件事情有空就去弄一下

​		最后说一下我学前端的方法把，一开始入门一个新知识的时候我一般喜欢去看公开课，因为很方便，而且一开始看视频也比较生动点，后面想继续深入的话一个是买书看，或者去看网上的官方技术文档或者别人整理的博客啥的，然后就开始去 Github 上找别人分享的公开项目去看别人源码怎么写的，差不多是这个流程

​		自我介绍差不多就是这些内容



---

### 项目中遇到问题

​		我想一下……印象比较深的一个是类组件改成函数式组件的一个坑，因为现在不都是推崇函数式组件开发吗，所以当时我也尝试了一下把以前的类组件换成函数式组件，然后我把类的生命周期函数功能用 hook 去替代的时候遇到的一个问题，当时用的是 useEffect 这个 hook，按照我的理解就是可以直接使用这个 hook 去实现 componentDidMount，componentDidUpdata 还有 componentWillUnmount 的功能，然后我当时有个代码功能是，组件更新和挂载的时候用 addEventListener 给一个标签元素添加一个事件，这个在类组件中是没有问题的，但是当我换成 useEffect 后就出现了问题，我每次更新组件，这个标签上面绑定的事件就会添加一个同名事件，然后没多久我的浏览器就卡死了，我当时很奇怪，因为 addEventListener 这个函数我试了是不会重复添加完全相同的事件函数的，后面这个问题我和同学一起研究了半天，发现原因出现在生命周期上，react 好像是对不同生命周期声明的同名变量，是看作不同的东西的，然后我类组件定义事件函数是在 render 函数外面，因此更新渲染时不会重复声明，但是函数式组件更新时会重复执行函数组件内所有代码，因此就重复声明了事件函数，然后这个同名事件函数因为生命周期的关系实际上是不同的，因此可以重复添加，所以到了最后我也算是明白了为什么在 useEffect 中绑定事件要在最后remove掉

​		还有 redux 中使用 saga 的问题，因为 saga 的写法感觉很绕，我一开始看别人的代码和看官方文档都有点看不懂，因为中间件我的理解就是为了拿到异步的数据进行处理然后再将最终数据传给 reducer 执行，而他不像 thunk，直接传一个 dispatch 方法让你用得时候就手动调用一下就好了，他有很多监听函数，所以给我的感觉就像是监听工具而不是当成一个中间件来使用，后面继续深入了解之后发现它的整个数据的流向还蛮有趣的，它先是设计了一个触发action，action A，用监听函数 比如 take 或者 takeEvery ，takeLatest 去监听 actionA 的触发，当手动 dispatch 触发 actionA 并传入数据的时候，触发 saga 的监听函数，从而触发 saga 函数，在 saga 函数中拿到从 actionA 传入的数据，经过一系列处理后，使用 put 函数触发一个 actionB，reducer 对 actionB 的 type 敏感，从而从 actionB 中拿到最终的数据并触发 reducer 函数，是这样一个比较绕的流程

​		最后还一个是项目中使用 TS 造成的数据类型问题，因为 TS 没有 JS 那么自由，可以随便写，TS 要考虑到数据类型的因素，比如一些可能为空的变量，它就不给你直接使用它的属性，要使用非空判断符 ? 或者 ! 额外处理一下，然后还有用到一些第三方包的时候，因为第三包对类型有明确要求，所以有些时候如果要使用又不知道他要传的数据类型从哪来的，就得去翻他那个包的源码或者声明文件看一下，以及我在看别人的源码时，有个地方不懂的是我发现有些包他们专门下载了 TS 的声明文件，但是有些包又不下载，这种取舍是依据什么来的，这点我还在研究，感觉得多几个源码才有更深的理解

​		项目中遇到的问题差不多就是这些



-----

### ES6新特性

​		我先说一下我实际用的比较多的吧

​		首先ES6的模块化有了新的分化，以前使用的 JS 模块称为 **CommonJS 模块**，主要使用 **require**导入， 现在新增了一个 **ES6模块**，使用的是 **import** 方式导入，然后我说说 require 和 import 的主要区别把，首先**require 同步加载**，**而 import 是异步加载**，就是 require 会在引入时执行模块文件代码，而 import 只有在用到该模块部分时才会执行，**require 在运行时加载**，**而 import 在编译时加载**，然后 require 只能**引入全部**的代码文件，而 import 可以**按需引入**，只引入一部分代码，还有一个比较重要的是 require 引用是**值的拷贝**，相当于把模块代码拷贝了一份到当前文件中，所以在当前文件对模块代码进行操作时不会影响到模块文件，而 import 相当于是**值的引用**，对模块代码进行操作会直接影响到模块文件代码，模块化的内容大概是那么多

​		然后 ES6 增加了一个作用域，**块级作用域**，以前的 JS 有三种作用域，一个是全局作用域，浏览器环境的话是 `window`，Node 环境的是 `global`，还有一个函数作用域，就是函数内部的，最后一个是动态作用域 this，它只有在执行时才会确定具体的作用域，ES6 增加了块级作用域，用大括号表示范围，主要体现在条件语句和循环语句中，同时为了和块级作用域搭配新增了两种声明变量的方式，**let** 和 **const** ，它们和 var 的一个主要区别是**不存在变量提升**，同一作用域下**不可以多次声明同名变量**

​		还有 ES6 新增了 **class**，相当于用原型链声明构造函数和实现继承的**语法糖**，**从构造函数功能来说**的话，以前的一些公共的方法或者属性得放在原型链的原型上，然后构造函数new的实例就可以顺着原型链拿到这些方法和属性，但是这样做也不保险，因为实例可以直接修改原型链上的引用类型数据，所以一般是在构造函数中将需要公开的方法和属性用this表示，这样 new 的时候 this 指向实例，就会在实例中创建这些方法和属性，这样改写的时候是优先改写自身的，就保障了原型链的安全，然后如果使用 class 的话就没有那么麻烦，直接在类中正常声明就好了，会自动隐性地添加到原型中，**从继承功能上来说**，以前实现继承的主要是用父类的实例对象来当成子类的原型，然后再在子类里调用一次父类构造函数并把 this 指向自己，而使用类则只需要简单的 extent 就能做到这些功能

​		ES6 比较常用的还有**箭头函数**，它和普通函数不同的是首先它并不是用函数式声明的，所以**不存在函数提升**，然后箭头函数最主要的特点是它**不产生this**，它的 this由最近父级函数产生，因此 **和最近父级函数 this 的指向完全一致**，而且不能通过更改 this 的函数如 call，apply，bind 来更改其指向，因为没有 this 所以不能作为构造函数，将 this 指向实例从而 new 一个实例出来，所以箭头函数是**没有原型链**的说法的，自然也**没有原型属性**，然后箭头函数也**没有 argument 对象**，因此如果获取剩余的传入形参则**使用 rest 参数**，最后箭头函数不能当做 Generator 函数来使用

​		然后ES6 为了解决获取异步数据产生的回调地狱，推出了**Promise 对象**还有 **async 函数**，首先 promise 处理异步主要使用的是链式调用的方式，使用 **resolve** 或者 **then** 来阻塞代码，只有成功执行并返回数据才会继续往下运行，而 async 的代码书写和同步代码类似，使用 **await** 关键字来阻塞下面代码，然后 promise 和 async 函数的错误处理方式也不同，promise 对象处理错误使用是链式调用 **catch** 或者 **reject**，而 async 使用的是 **try-catch** 代码块，我自己平时比较喜欢用 async 函数，因为可以随时拿到我想要的数据保存起来到后面任意时刻用，而不需要像 promise 对象一样层层传递，不过 async 函数也有做不了的事情，需要 promise 的配合，比如同时开始多个异步任务就要使用 promise 的 **all** 或 **race** 方法，同时 ES6 还推出了 **generator 函数**，也可以用来阻塞异步操作，我主要在 redux-saga 中用过

​		ES6 还增加了几种数据结构，比如 **Set** 和 **Map**，Set 没有键，只有值，最主要的特点是存储的**数据唯一**不能重复，因此常常用来便捷实现数组去重，Map 是一种键值的存储类型，和 JS 中的对象类似，但是对象的键只能为字符串类型，为了解决这个问题，就出现了 Map 类型，**键值都可以为任意数据类型**，同时 Set 和 Map 对自身内部的数据是**强引用**，即使是在全局把存储的数据设为 null，它们也不会被垃圾回收机制清除，有使用因此又出现了 **WeakSet** 和 **WeakMap**，它们的特点是存储的**值只能为引用类型且不能被遍历**，内部数据**可被垃圾回收**

​		还有一个就是 ES6 新增了一种原始数据类型 **Symbol**，它的特点是**唯一性**，一般用来当做一个对象的私有属性，因为它没办法被普通方法比如 `for-in` 和 `object.key()` 获取到，一般要获取使用的是 `Symbol.for()` 方法，有点类似单例设计模式，没有就创建一个，有了就返回创建好的那个

​		我主要了解的 ES6 知识差不多这些



----

### Webpack

​		我先说说我对 webpack 总的理解吧，webpack 首先是一个打包工具，它的作用就是将编写的代码加工打包处理，最终运行的项目是经过处理后优化的项目，主要的一个作用是压缩代码，减少项目文件大小，还有为项目加一些额外的比如便于开发的功能

​		webpack 主要配置的是 **loader** 和 **plugins**，**webpack 自身只能识别 JS 和 JSON**，因此如果要将使用其他语言的代码进行打包，需要配置 loader 匹配对应的文件名后缀并采用对应的打包方式比较常见的两个一个是 `css-loader`，然后还有 css 预处理器 `less-loader`，为了将识别 ES6 语法代码，需要配置 `babel-loader`，所以 loader 的作用是让 webpack 能够去处理那些非 JS 文件，一共文件只能同时被一个 loader 进行处理，如果需要用到多个 loader，必须写正确**处理顺序**，比如处理 less 要先使用 less-loader 将 less语言 编译为 css，然后再用 css-loader 让 webpack 对 css 进行打包处理

​		plugins 一般在 webpack 中通过 new 一个实例对象了来使用，**主要处理的是大量的资源**，包括打包优化和压缩等，最主要的是 `html-webpack-plugin`，它相当于一个容器，创建了一个 html 文件，自动引入打包后的所有资源使用，同时，它也可以进行一些代码压缩配置，比如移除空格和注释以减少代码字数等

​		然后我再说一些我自己尝试配过 webpack 的一些功能吧，因为具体配置做法都是参考别人视频或者文档的，所以只能说说拥有的功能

​		首先是**页面的处理**，比如压缩 html

​		然后是**样式处理**，比如压缩 css，还有 css 兼容，只要写最原始的 css，然后 webpack 打包的时候会自动对需要兼容的 css 语句加上兼容各个浏览器的前缀，所以现在 css 一般都不怎么需要考虑各个浏览器的兼容问题，webpack 已经自动帮我们处理好了

​		还有**资源处理**，一个是动态资源，处理的是 js 中 import 或者 css 里直接引用的资源，一个是静态资源，处理的是 html 里直接导入的资源，可以为这些资源设定目标文件夹，编译器自动往指定文件夹中寻找资源，省去开发中写多段路径

​		还有**js 处理**，比如压缩 js，兼容 es6，还有代码语法检查，比较出名的库是 `eslint`

​		最后是 **webpack 打包的优化**，先说几个比较重要的吧，首先是配置**代码调试**，主要体现在如果出现报错，在浏览器就可以直接查到具体的报错原因和报错的具体哪行代码，还有一个是**树摇**功能，就是出去文件中含有但是实际上没有被使用的代码，然后还有代码分割功能，如果没有进行**代码分割**，整个项目的所有 js 只会打包合并成一个总的 js 文件，而且我们代码中互相引用的包可能会多次重复引用，打包后代码的体积就变多了，因此可以使用代码分割将公共的引用代码抽离一个单独文件，然后只需要引入公共的部分就行，然后还可以配置 **PWA**，渐进式网络开发程序，就是网络离线的时候也可以从缓存里读取网站的部分数据，让用户体验好点

​		优化的内容还有一点，关于**打包速度**问题的，比如 **loader 匹配**，本来一个 loader 是遍历所有 loader 的，配置匹配项可以让一个 loader 寻找到对应目标后便退出，不再往下匹配，还有**缓存配置**，比如使用 babel 时，每次 js 改动时会将所有的 js 代码重新编译一次，开启 babel 缓存后则读取缓存然后只改动变动代码，还可以对资源文件名设置哈希值，如果文件内容没有改动，则本次打包后哈希值和上次一样，这是为了协商缓存的判定，这样浏览器就不会每次都请求同样的文件，而是可以从缓存里读取，还有 webpack 可以配置**多进程打包**啥的

​		我所知道的 webpack 大概就是那么多



---















​		



