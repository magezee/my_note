## 问答笔记

### 介绍







### ES6新特性

​		我先说一下我实际用的比较多的吧

​		首先ES6的模块化有了新的分化，以前使用的 JS 模块称为 **CommonJS 模块**，主要使用 **require**导入， 现在新增了一个 **ES6模块**，使用的是 **import** 方式导入，然后我说说 require 和 import 的主要区别把，首先**require 同步加载**，**而 import 是异步加载**，就是 require 会在引入时执行模块文件代码，而 import 只有在用到该模块部分时才会执行，**require 在运行时加载**，**而 import 在编译时加载**，然后 require 只能**引入全部**的代码文件，而 import 可以**按需引入**，只引入一部分代码，还有一个比较重要的是 require 引用是**值的拷贝**，相当于把模块代码拷贝了一份到当前文件中，所以在当前文件对模块代码进行操作时不会影响到模块文件，而 import 相当于是**值的引用**，对模块代码进行操作会直接影响到模块文件代码，模块化的内容大概是那么多

​		然后 ES6 增加了一个作用域，**块级作用域**，以前的 JS 有三种作用域，一个是全局作用域，浏览器环境的话是 `window`，Node 环境的是 `global`，还有一个函数作用域，就是函数内部的，最后一个是动态作用域 this，它只有在执行时才会确定具体的作用域，ES6 增加了块级作用域，用大括号表示范围，主要体现在条件语句和循环语句中，同时为了和块级作用域搭配新增了两种声明变量的方式，**let** 和 **const** ，它们和 var 的一个主要区别是**不存在变量提升**，同一作用域下**不可以多次声明同名变量**

​		还有 ES6 新增了 **class**，相当于用原型链声明构造函数和实现继承的**语法糖**，**从构造函数功能来说**的话，以前的一些公共的方法或者属性得放在原型链的原型上，然后构造函数new的实例就可以顺着原型链拿到这些方法和属性，但是这样做也不保险，因为实例可以直接修改原型链上的引用类型数据，所以一般是在构造函数中将需要公开的方法和属性用this表示，这样 new 的时候 this 指向实例，就会在实例中创建这些方法和属性，这样改写的时候是优先改写自身的，就保障了原型链的安全，然后如果使用 class 的话就没有那么麻烦，直接在类中正常声明就好了，会自动隐性地添加到原型中，**从继承功能上来说**，以前实现继承的主要是用父类的实例对象来当成子类的原型，然后再在子类里调用一次父类构造函数并把 this 指向自己，而使用类则只需要简单的 extent 就能做到这些功能

​		ES6 比较常用的还有**箭头函数**，它和普通函数不同的是首先它并不是用函数式声明的，所以**不存在函数提升**，然后箭头函数最主要的特点是它**不产生this**，它的 this由最近父级函数产生，因此 **和最近父级函数 this 的指向完全一致**，而且不能通过更改 this 的函数如 call，apply，bind 来更改其指向，因为没有 this 所以不能作为构造函数，将 this 指向实例从而 new 一个实例出来，所以箭头函数是**没有原型链**的说法的，自然也**没有原型属性**，然后箭头函数也**没有 argument 对象**，因此如果获取剩余的传入形参则**使用 rest 参数**，最后箭头函数不能当做 Generator 函数来使用

​		然后ES6 为了解决获取异步数据产生的回调地狱，推出了**Promise 对象**还有 **async 函数**，首先 promise 处理异步主要使用的是链式调用的方式，使用 **resolve** 或者 **then** 来阻塞代码，只有成功执行并返回数据才会继续往下运行，而 async 的代码书写和同步代码类似，使用 **await** 关键字来阻塞下面代码，然后 promise 和 async 函数的错误处理方式也不同，promise 对象处理错误使用是链式调用 **catch** 或者 **reject**，而 async 使用的是 **try-catch** 代码块，我自己平时比较喜欢用 async 函数，因为可以随时拿到我想要的数据保存起来到后面任意时刻用，而不需要像 promise 对象一样层层传递，不过 async 函数也有做不了的事情，需要 promise 的配合，比如同时开始多个异步任务就要使用 promise 的 **all** 或 **race** 方法，同时 ES6 还推出了 **generator 函数**，也可以用来阻塞异步操作，我主要在 redux-saga 中用过

​		ES6 还增加了几种数据结构，比如 **Set** 和 **Map**，Set 没有键，只有值，最主要的特点是存储的**数据唯一**不能重复，因此常常用来便捷实现数组去重，Map 是一种键值的存储类型，和 JS 中的对象类似，但是对象的键只能为字符串类型，为了解决这个问题，就出现了 Map 类型，**键值都可以为任意数据类型**，同时 Set 和 Map 对自身内部的数据是**强引用**，即使是在全局把存储的数据设为 null，它们也不会被垃圾回收机制清除，有使用因此又出现了 **WeakSet** 和 **WeakMap**，它们的特点是存储的**值只能为引用类型且不能被遍历**，内部数据**可被垃圾回收**

​		还有一个就是 ES6 新增了一种原始数据类型 **Symbol**，它的特点是**唯一性**，一般用来当做一个对象的私有属性，因为它没办法被普通方法比如 `for-in` 和 `object.key()` 获取到，一般要获取使用的是 `Symbol.for()` 方法，有点类似单例设计模式，没有就创建一个，有了就返回创建好的那个

​		我主要了解的 ES6 知识差不多这些



----

### Webpack

​		我先说说我对 webpack 总的理解吧，webpack 首先是一个打包工具，它的作用就是将编写的代码加工打包处理，最终运行的项目是经过处理后优化的项目，主要的一个作用是压缩代码，减少项目文件大小，还有为项目加一些额外的比如便于开发的功能

​		webpack 主要配置的是 **loader** 和 **plugins**，**webpack 自身只能识别 JS 和 JSON**，因此如果要将使用其他语言的代码进行打包，需要配置 loader 匹配对应的文件名后缀并采用对应的打包方式比较常见的两个一个是 `css-loader`，然后还有 css 预处理器 `less-loader`，为了将识别 ES6 语法代码，需要配置 `babel-loader`，所以 loader 的作用是让 webpack 能够去处理那些非 JS 文件，一共文件只能同时被一个 loader 进行处理，如果需要用到多个 loader，必须写正确**处理顺序**，比如处理 less 要先使用 less-loader 将 less语言 编译为 css，然后再用 css-loader 让 webpack 对 css 进行打包处理

​		plugins 一般在 webpack 中通过 new 一个实例对象了来使用，**主要处理的是大量的资源**，包括打包优化和压缩等，最主要的是 `html-webpack-plugin`，它相当于一个容器，创建了一个 html 文件，自动引入打包后的所有资源使用，同时，它也可以进行一些代码压缩配置，比如移除空格和注释以减少代码字数等

​		然后我再说一些我自己尝试配过 webpack 的一些功能吧，因为具体配置做法都是参考别人视频或者文档的，所以只能说说拥有的功能

​		首先是**页面的处理**，比如压缩 html

​		然后是**样式处理**，比如压缩 css，还有 css 兼容，只要写最原始的 css，然后 webpack 打包的时候会自动对需要兼容的 css 语句加上兼容各个浏览器的前缀，所以现在 css 一般都不怎么需要考虑各个浏览器的兼容问题，webpack 已经自动帮我们处理好了

​		还有**资源处理**，一个是动态资源，处理的是 js 中 import 或者 css 里直接引用的资源，一个是静态资源，处理的是 html 里直接导入的资源，可以为这些资源设定目标文件夹，编译器自动往指定文件夹中寻找资源，省去开发中写多段路径

​		还有**js 处理**，比如压缩 js，兼容 es6，还有代码语法检查，比较出名的库是 `eslint`

​		最后是 **webpack 打包的优化**，先说几个比较重要的吧，首先是配置**代码调试**，主要体现在如果出现报错，在浏览器就可以直接查到具体的报错原因和报错的具体哪行代码，还有一个是**树摇**功能，就是出去文件中含有但是实际上没有被使用的代码，然后还有代码分割功能，如果没有进行**代码分割**，整个项目的所有 js 只会打包合并成一个总的 js 文件，而且我们代码中互相引用的包可能会多次重复引用，打包后代码的体积就变多了，因此可以使用代码分割将公共的引用代码抽离一个单独文件，然后只需要引入公共的部分就行，然后还可以配置 **PWA**，渐进式网络开发程序，就是网络离线的时候也可以从缓存里读取网站的部分数据，让用户体验好点

​		优化的内容还有一点，关于**打包速度**问题的，比如 **loader 匹配**，本来一个 loader 是遍历所有 loader 的，配置匹配项可以让一个 loader 寻找到对应目标后便退出，不再往下匹配，还有**缓存配置**，比如使用 babel 时，每次 js 改动时会将所有的 js 代码重新编译一次，开启 babel 缓存后则读取缓存然后只改动变动代码，还可以对资源文件名设置哈希值，如果文件内容没有改动，则本次打包后哈希值和上次一样，这是为了协商缓存的判定，这样浏览器就不会每次都请求同样的文件，而是可以从缓存里读取，还有 webpack 可以配置**多进程打包**啥的

​		我所知道的 webpack 大概就是那么多

​		



