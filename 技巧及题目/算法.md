## 算法

### 复杂度

#### 时间复杂度

预估代码的基本操作执行次数，而非绝对执行时间

##### 常见方式

**线性**

$$T(n) = 3n$$，执行次数是线性的

```c#
void eat(int n){
    for(int i=0; i<n; i++){;
        System.out.println("等待一天");
        System.out.println("等待一天");
        System.out.println("吃一寸面包");
    }
```

**对数**

 $$ T(n)=5log_2n $$，执行次数是对数的，一般会写成省略底数2（因为默认底数为2） $$ T(n)=5log n$$

```c#
void eat(int n){
   for(int i=1; i<n; i*=2){
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("吃一半面包");
   }
// 即2^x = n， 循环次数x = log(n) 2为底
// 每一步里面执行了5次代码因此乘五
```

**常量**

$$T(n) = 2$$，执行次数是常量的

```c#
void eat(int n){
   System.out.println("等待一天");
   System.out.println("吃一个鸡腿");
}
// 执行了多少次与n的值无关，固定2次
```

**多项式**

$$ T(n)=0.5n^2+0.5n $$

```c#
void eat(int n){
   for(int i=0; i<n; i++){
       for(int j=0; j<i; j++){
           System.out.println("等待一天");
       }
       System.out.println("吃一寸面包");
   }
// 本质上是1+2+3+..+n-1+n = (1+n)*n/2 = 0.5n^2+0.5n (多项式求和公式)
```

----

##### 渐进时间复杂度

上面是基本操作执行次数的函数T(n)，但仅靠这个来分析和比较一段代码的运行时间仍有不足，比较不同算法的运行时间需要由n的取值决定

```
若存在函数 f（n），使得当n趋近于无穷大时，T（n）/ f（n）的极限值为不等于零的常数，则称 f（n）是T（n）的同数量级函数
记作 T（n）= O（f（n）），称O（f（n）） 为算法的渐进时间复杂度，简称时间复杂度。
渐进时间复杂度用大写O来表示，所以也被称为大O表示法
```

即时间复杂度将时间规模函数T(n)简化为一个数量级（如n，n^2 ，n^3……）

**推导出时间复杂度原则**

- 如果运行时间是常数量级，用常数1表示；

- 只保留时间函数中的最高阶项；

- 如果最高阶项存在，则省去最高阶项前面的系数。

----

**线性：**

$$T(n) = 3n$$

最高阶项为3n，省去系数3，转化的时间复杂度为n

$$T(n) = O(n)$$

----

**对数阶**

 $$ T(n)=5log_2n $$

最高阶项为$$5log_2n$$，省去系数5，转化的时间复杂度为$$log_2n$$，一般会省略写底数，默认2

·$$T(n) = O（logn）$$

---

**常量**

$$T(n) = 2$$

只有常量时，统一写为1

$$T(n) = O（1）$$

---

**多项式**

$$ T(n)=0.5n^2+0.5n $$

最高阶项为$$0.5n^2$$，省去系数0.5，转化的时间复杂度为$$n^2$$

$$T(n) = O（n^2）$$

----

以上四种时间复杂度耗时：

$$O（1）< O（logn）< O（n）< O（n^2)$$

除了上述的四个场景，还有许多不同形式的时间复杂度

$$O（nlogn）、O（n^3）、 O（m*n）、O（2^n）、O（n！）$$

-----

##### 计算时间复杂度

**常数阶O(1)**

```
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)
它消耗的时间并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度
```

```c#
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```

**线性阶O(n)**

```
循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度，一层循环
```

```c#
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

**对数阶O(logN)**

```
当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)
```

```c#
int i = 1;
while(i<n)
{
    i = i * 2;
}
```

**线性对数阶O(nlogN)**

```
时间复杂度为O(logn)的代码循环N遍,那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)
```

```c#
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```

**平方阶O(n²)**

```
O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) ，里外循环次数都由n决定，因此n*n=n^2，两层嵌套循环
```

```c#
for(x=1; i<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

如果将其中一层循环的参数变化，即n改成m，那它的时间复杂度就变成了 O(m*n)

```c#
for(x=1; i<=m; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

**立方阶O(n³)**、**K次方阶O(n^k)**

```
O(n³)相当于三层n循环，k则为k层n循环
```



----

#### **空间复杂度 **

```c#
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
// 第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)
```



----

### 排序

```
各排序过程动图可以看这个：https://www.cnblogs.com/AlbertP/p/10847627.html
```

#### 冒泡排序

时间复杂度：O(n²)

每一轮将最小/最大的数排在最后

实现方法：

- 如给定一个数组[5, 3, 4, 1]从小到大冒泡排序
- 按顺序两两进行排序，如果大则调换顺序第一次[3, 5, 4, 1]，第二次[3, 4, 5, 1]，最终[3, 4, 1, 5]
- 第一轮排序结束时，就可以将最大的排在最后一位，第二轮开始则将第二大的排在倒数第二位，以此重复，由于最后一位已经是最大了，不需要进行排序，因此第二轮排序时可以不需要和最后一个进行对比，以此同理，当已经进行n次排序时，则无需对数组`length-n-1`坐标进行对比

```js
function bubbleSort(arr) {
    var len = arr.len
    for(var i = 0; i < len; i++) {
        for(var j = 0; j < len - i - 1; j++) {
            if(arr[j] > arr[j+1]) {     // 相邻元素两两对比，最终将最大的放在数组最后
                var temp = arr[j+1]
                arr[j+1] = arr[j]
                arr[j] = tmep
            }
        }
    }
}
```



---

#### 选择排序

时间复杂度：O(n²)

每一轮将最小/最大的数排在最前面

实现方法：

- 如给定一个数组[5, 3, 4, 1]从小到大冒泡排序
- 从数组第一位开始，遍历整个数组，记录数组最小值的下标，将其和第一位调换位置[1, 3, 4, 5]，接着从数组第二位开始，以此重复（由于第一位肯定已经排序好，因此之后可以从第二位开始，即第n轮可以从第`n+1`为开始）

```js
function selectionSort(arr) {
    var len = arr.length
    var minIndex, temp
    for(var i = 0; i < len -1; i++ ) {
        minIndex = i
        for(var j = i + 1; j < len; j++) {
            if(arr[j] < arr[minIndex]) {
                minIndex = j
            }
        }
        temp = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = temp
    } 
}

var arr = [4,1,2,0]
selectionSort(arr)
console.log(arr)
```





